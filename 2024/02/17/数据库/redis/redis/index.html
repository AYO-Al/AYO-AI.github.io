<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>AYO | AYO</title><meta name="author" content="AYO,2609320892@qq.com"><meta name="copyright" content="AYO"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="AYO"><meta name="application-name" content="AYO"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="AYO"><meta property="og:url" content="https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/index.html"><meta property="og:site_name" content="AYO"><meta property="og:description" content="1.什么是Redis？Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务，是一个基于内存的键值型NOSQL数据库，基于c语言编写 特征：  键值型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性(redis6.0只有对网络请求处理才是"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://ayo-al.github.io/img/preview.jpg"><meta property="article:author" content="AYO"><meta property="article:tag" content=""><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ayo-al.github.io/img/preview.jpg"><meta name="description" content="1.什么是Redis？Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务，是一个基于内存的键值型NOSQL数据库，基于c语言编写 特征：  键值型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性(redis6.0只有对网络请求处理才是"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.yuki.love',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: undefined,
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: {"appId":"XMRZIUY8NL","apiKey":"187af2610e1cc500c95dc8b8f3a53d0e","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: AYO","link":"链接: ","source":"来源: AYO","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'AYO',
  title: 'AYO',
  postAI: '',
  pageFillDescription: '1.什么是Redis？, 1.1.认识NOSQL, 1.2.Redis应用场景, 2.Redis学习准备, 2.1.Redis在Windows安装, 2.2.Redis在Linux安装, 2.3.配置文件配置, 2.3.Redis客户端, 2.3.1.命令行客户端, 2.3.2.图形化桌面客户端, 3.Redis数据结构, 3.1.key通用命令, 3.2.key的层级结构, 3.3.String类型, 3.3.1.String常用命令, 3.4.Hash类型, 3.4.1.Hash常见命令, 3.5.List类型, 3.5.1.List常用命令, 3.6.set类型, 3.6.1.Set常见命令, 3.7.SortedSet类型, 3.7.1.SortedSet类型常用命令, 3.8.geospatial 地理位置, 3.8.1.GEO常见操作, 3.9.HyperLogLog, 3.10.Bitmaps, 3.11.Stream, 3.12.XREADGROUP GROUP, 4.慢查询, 5.事务, 5.1.事务常用命令, 5.2.乐观锁, 6.Redis持久化, 6.1.RDB(Redis DataBase), 6.2.AOF(Append Only File), 6.3.总结, 6.4.Redis持久化的取舍和选择, 6.5.Redis持久化运维常见问题, 7.发布订阅, 7.1.订阅常用命令, 7.2.原理, 8.Redis连接命令, 9.Redis服务器, 10.Redis客户端连接, 11.Redis 性能测试, 12.Redis管道技术(pipeline), 13.Redis主从复制, 13.1.基础, 13.2.Redis Sentinel架构, 13.3.总结, 14.Redis Cluster, 14.1.数据分布, 14.2.Redis Cluster架构, 14.3.Redis Cluster安装, 14.4.集群伸缩, 14.5.客户端路由, 14.6.如何实现批量操作, 14.7.故障转移, 14.8.Redis Cluster常见问题, 14.9.集群总结, 15.缓存, 15.1.Redis缓存穿透, 15.2.Redis缓存雪崩, 15.3.无底洞问题, 15.4.热点key重建优化, 16.Redis云平台Cachecloud, 16.1.Redis规模化困扰, 17.基于Redis的分布式布隆过滤器, 17.1.布隆过滤器原理, 17.2.误差率, 17.3.布隆过滤器, 18.Redis开发规范, 18.1.键值设计, 18.2.命令优化, 18.3.客户端优化, 19.内存管理, 19.1.Redis内存消耗, 19.2.内存管理, 19.3.内存优化, 20.开发运维常见坑, 20.1.Linux内核优化, 20.2.安全的Redis, 20.3.热点key, 21.Redis的python客户端, 22.python使用Redis, 22.1.python连接redis, 22.2.连接池, 22.3.管道, 22.4.发布与订阅, 22.5.哨兵, 22.6.集群什么是诞生于年全称是远程词典服务是一个基于内存的键值型数据库基于语言编写特征键值型支持多种不同数据结构功能丰富单线程每个命令具备原子性只有对网络请求处理才是多线程低延迟熟读快基于内存多路复用良好的编码支持数据持久化可以将内存中的数据保存在磁盘中重启的时候可以再次加载进行使用支持数据的备份即模式的数据备份支持主从集群分片集群支持多语言客户端开源优点支持多种语言的客户端性能极高读数据的速度是次写的速度是次丰富的数据类型原子的所有操作都是原子性的意思是要么执行成功要么完全失败单个操作是原子性的多个操作也支持事务即原子性通过和指令包起来丰富的特性还支持通知过期等等特性认识与的对比数据结构结构化非结构化数据关联关联的非关联的查询方式查询非事务特性存储方式磁盘内存扩展性垂直水平使用场景数据结构固定相关业务对数据安全性一致性要求较高数据结构不固定对一致性安全性要求不高对性能高应用场景缓存系统计数器消息队列系统排行榜社交网络实时系统学习准备官网在线测试命令参考在安装官网是提供的命令行客户端是的服务端启动脚本性能测试工具文件修复工具文件检查工具是的哨兵启动脚本测试连接在连接后输出该命令返回则连接成功在安装下载压缩包解压创建软链接编译安装三种启动方式最简启动动态参数启动配置文件启动三种启动方式比较生产环境选择配置启动单机多实例配置文件可以用端口区分开客户端返回值配置文件配置客户端安装完后我们就可以操作实现数据的了这需要用到客户端包括命令行客户端图形化桌面客户端编程客户端命令行客户端安装完成后就自带了命令行客户端使用方式如下其中常见的有指定要连接的节点的地址默认是指定要连接的节点的端口默认是指定的访问密码其中就是的操作命令例如与服务器做心跳测试服务器正常会返回图形化桌面客户端大神编写的客户端直接下载安装就能用数据结构是一个的数据库一般是类型不过的类型多种多样通用命令查看一个命令的具体用法符合条件的值具体模板可以去官网查看不建议在生产环境中使用删除的元素数量删除不存在的元素不计算在内有返回无返回计算总数可以去掉过期时间过期后返回代表永久有效时间复杂度命令时间复杂度的层级结构没有类似中的的概念我们该如何区分不同类型的呢例如需要存储用户商品信息到用户是商品也是的允许有多个单词形成层级结构多个单词之间用隔开格式如下项目名业务名类型例如项目名称叫有和两种不同类型的数据我们可以这样定义设置数据时这样多插入几个后会在中形成层级结构类型类型也就是字符串类型是中最简单的存储类型其是字符串不过根据字符串的格式不同又分为类普通字符串整数类型可以做自增自减副段类型可以做自增自减不管是那种底层都是字节数组形式存储之不贵是编码方式不同字符串类型的最大空间不能超过结构是将对象序列化为字符串后存储当需要修改对象的某个字段时很不方便常用命令添加或者修改已经存在的类型的键值对根据获取类型的批量添加对个类型的键值对根据对个获取多个类型的让一个整型的自增让一个整型的自增并指定步长让一个浮点类型的数字自增并指定步长添加一个类型的键值对前提是这个不存在否则不执行添加一个类型的键值对并且指定有效期类型类型也叫散列其是一个无序字典类似于中的结构是中一个类型的字段和值的映射表特别适合用于存储对象每个可以存储个键值对结构可以将对象中的每个字段独立存储可与针对单个字段做常见命令添加或者修改类型的的值获取一个类型的的值批量添加多个类型的的值批量获取对个类型的的值获取一个类型的中的所有和获取一个类型中的所有获取一个类型的中的所有让一个类型的字段值自增并指定步长添加一个类型的的值前提是这个不存在否则不执行类型中的类型与中的类似可以看做是一个双向链表结构支持正向检索也可以支持反向检索一个列表最多可以包含个元素特征有序元素可以重复插入和删除快查询速度一般常用命令向列表左侧插入一个或多个元素移除并返回列表左侧的第一个元素没有则返回向列表右侧插入一个或多个元素移除并返回列表左侧的第一个元素没有则返回返回一段角标范围内的所有元素和与和类似只不过在没有元素时等待指定时间而不是直接返回类型的结构与中的类型可以看做是一个以为的也是一个表因此具备与类似的特征中最多可以为无序元素不可重复查找快支持交集并集差集等功能常见命令向中添加一个或多个元素移除中的指定元素返回中元素的个数判断一个元素是否存在与中获取中所有的元素求多个的交集求多个的差集求多个的并集类型的是一个可排序的集合与中的有些类似但底层数据结构却差别很大中的每一个元素都带有一个属性可以基于对属性对元素排序底层的实现是一个跳表加表特性如下可排序元素不可重复查询速度快因为的可排序性经常被用来实现排行榜这样的功能类型常用命令添加一个或多个元素到如果已经存在则更新其值删除中的一个指定元素获取指定元素的值获取中指定元素的排名获取中的元素个数统计值在给定范围内的所有元素的个数让中的指定元素自增步长为指定的值按照排序后获取指定排名范围内的元素按照排序后获取指定范围内的元素求差集交集并集所有默认排序全为升序排序若要降序则在命令的后面加地理位置主要用于存储地理位置信息并对存储的信息进行操作有效的经度从度到度有效的纬度从度到度当坐标位置超出上述指定范围时该命令将会返回一个错误内部使用的类型为常见操作添加地理坐标的位置获取地址位置的坐标计算两个位置之间的距离根据用户给定的经纬度坐标来获取指定范围内的地理位置集合根据存在位置集合里面的某个地点获取指定范围内的地理位置集合返回一个或多个位置对象的值用于存储指定的地理空间位置可以将一个或者多个经度纬度位置名称添加到指定的中语法格式如下实例用于从给定的里返回所以指定名称的位置不存在返回语法实例用于返回两个给定位置之间的距离语法最后一个距离单位参数说明米默认单位千米英里英尺实例以给定的经纬度为中心返回键包含的位置元素当中与中心的距离不超过给定最大距离的所有位置元素和命令一样都可以找出位于指定范围内的元素但是的中心点是由给定的位置元素决定的而不是使用经度和纬度来决定中心点语法格式参数说明将位置元素的经度和纬度也一并返回在返回位置元素的同时将位置元素与中心之间的距离也一并返回以位有符号整数的形式返回位置元素经过原始编码的有序集合分值这个选项主要用于底层应用或者调试实际中的作用并不大限定返回的记录数查找结果根据距离从近到远排序从远到近排序将返回结果的地理位置信息保存到指定键将返回结果距离中心节点的距离保存到指定键实例使用来保存地理位置的坐标用于获取一个或多个位置元素的值语法格式如下实例是用来做基数统计的算法的优点是在输入元素的数量或者体积非常非常大时计算基数所需的空间总是固定的并且是很小的在里面每个键只需要花费内存就可以计算接近个不同元素的基数这和计算基数时元素越多耗费内存就越多的集合形成鲜明对比但是因为只会根据输入元素来计算基数而不会储存输入元素本身所以不能像集合那样返回输入的各个元素常用命令添加指定元素到返回给定的基数估算值将多个合并为一个使用经验是否能容忍错误错误率是否需要单条数据中的位存储可以用来统计用户信息如活跃状态打卡等位图数据结构都是操作二进制位来进行记录就只有和两个状态特别节省内存给位图指定索引设置值返回原先这个位置的值获取给定偏移量的值获取位图指定范围单位为字节默认为全部位值为的个数做多个的交集并集非异或操作并将结果保存在中计算位图指定范围第一个出现或的位置记录周一到周天的打卡设置星期一未打卡查看星期一是否打卡统计中的个数做交集放在中是版本新增加的数据结构主要用于消息队列本身是有一个发布订阅来实现消息队列的功能但它有个缺点就是消息无法持久化如果出现网络断开宕机等消息就会被丢弃简单来说发布订阅可以分发消息但是无法记录历史消息而提供了消息的持久化和主备复制功能可以让任何客户端访问任何时刻的数据并且能记住每一个客户端的访问位置还能保证消息不丢失的结构如下所示它有一个消息链表将所有加入的消息都串起来每个消息都有一个唯一的和对应的内容每个都有唯一的名称它就是的在我们首次使用指令追加消息时自动创建消费组使用命令创建一个消费组有多个消费者游标每个消费组会有个游标任意一个消费组读取了消息都会使游标往前移动消费组的状态变量作用是维护消费组未确认的记录了当前已经被客户端读取的消息但是还没有确认字符消息队列相关命令添加消息到末尾对流进行修剪限制长度删除消息获取流包含的元素数量即消息长度获取消息列表会自动过滤已经删除的消息反向获取消息列表从大到小以阻塞或非阻塞方式获取消息列表消费者组相关命令创建消费组组读取消费者组中的消息将消息标记为已处理为消费者组设置新的最后传送消息删除消费者删除消费者组显示待处理消息的相关信息转移消息的归属权查看流和消费者组的相关信息打印消费者组的信息打印流信息使用向队列添加消息如果指定的队列不存在则创建一个队列队列名称消息可以使用表示由生成可以自定义但是要保证递增性记录实例使用对流进行修剪限制长度消息队列长度数量实例使用删除消息实例使用获取流包含的元素即消息长度实例使用获取消息列表会自动过滤已经删除的消息队列名开始值表示最小值结束值表示最大值数量实例使用以阻塞或非阻塞方式获取消息列表语法格式数量可选阻塞毫秒数没有设置就是非阻塞模式队列名消息实例从头部读取两条消息使用创建消费者组语法格式队列名称如果不存在就创建组名表示从尾部开始消费只接受新消息当前消息会全部忽略实例从头开始消费从尾部开始消费使用读取消费组中的消息语法格式消费组名消费者名读取数量阻塞毫秒数队列名消息实例慢查询生命周期慢查询发生在第三阶段客户端超时不一定慢查询但慢查询时客户端超时的一个可能因素两个配置先进先出队列固定长度保存在内存内慢查询阈值微秒记录所有命令不记录所有命令配置方法默认值修改配置文件重启动态配置慢查询命令获取慢查询队列获取慢查询队列长度清空慢查询队列运维经验不要过小通常设置左右不要设置过大默认通常设置理解生命周期定期持久化慢查询事务事务一组命令的集合单挑命令保存原子性但是事务不保证原子性批量操作在发送命令前被放入队列缓存收到命令后进入事务执行事务中任意命令执行失败其余的命令依然被执行在事务执行过程其他客户端提交的命令请求不会插入到事务执行命令序列中一次性顺序性排他性事务流程开始事务命令入队执行事务事务常用命令取消事务放弃执行事务块内的所有命令执行所有事务块内的命令标记一个事务块的开始取消命令对所有的监视监视一个或多个如果事务执行之前这个被其他命令所改动那么事务被打断实例乐观锁悲观锁很悲观认为什么时候都会出问题无论做什么都会加锁乐观锁很乐观认为什么时候都不会除问题所以不会上锁测试多线程修改值在事务中用来实现乐观锁持久化是内存数据库如果不将内存中的数据库状态保存到磁盘那么一旦服务器进程退出服务器中的数据库状态也会消失所以提供了持久化功能所有数据保存在内存中对数据的更新将异步的保存在磁盘上什么是在主从复制中就是备用在从机上在指定的时间间隔内将内存中的数据集快照写入磁盘也就是快照它恢复时是将快照文件直接读到内存里会单独创建一个子进程来进行持久化会先将数据写入到一个临时文件中待持久化过程都结束了再用这个临时文件替换上次持久化好的文件整个过程中主进程是不进行任何操作的这就确保了极高的性能如果需要进行大规模数据的回复且对于数据恢复的完整性不是非常敏感那方式要比方式更加的高效的缺点是最后一次持久化后的数据可能丢失默认就是一般情况下不需要修改配置保存的文件是触发机制配置中设置自动持久化执行秒内至少有一次修改则触发保存操作秒内至少有次修改则触发保存操作秒内至少有万次修改则触发保存操作生成的文件名生成文件的存放路径当写入发送错误是否停止文件是否使用压缩格式是否对文件进行校验全量复制执行命令也会触发规则但是得到的是一个空文件退出进程也会触发持久化命令执行的情况下会自动生成文件此命令是同步命令会堵塞其他命令如果有老的文件则会被新文件替换是异步的如何恢复文件只需要将文件放在存放目录启动的时候回自动检测恢复其中的数据查看启动目录优点适合大规模的数据恢复对数据完整性要求不高缺点需要一定的时间间隔进程操作如果以外宕机了这个最后一次修改数据就没有的了进程的时候会占用一定的内容空间总结时内存到硬盘的快照用于持久化通常会阻塞不会阻塞但是会新进程自动配置满足任一就会被执行有些触发机制不容忽视将我们的所有命令都记录下来恢复的时候就再重复执行一遍是什么以日志的形式来记录每个写操作将执行过的所有指令记录下来读操作不记录只许追加文件但不也可以改写文件启动之初会读取该文件重新构建数据换言之重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作保存的是文件默认是不开启的要开启的话将配置文件中改成如果文件有错位这时候是启动不起来的我们需要修复这个文件给我们提供了一个工具修复文件三种策略默认重写对过期的没有用的重复的可优化的数据进行化简可以减少硬盘占用量加速恢复速度重写实现的两种方式命令重写配置配置名含义文件重写需要的尺寸文件增长率统计名含义当前尺寸字节上次启动和重写的尺寸字节相关配置表示在日志重写时不进行命令追加操作而只是将命令放在重写缓冲区里避免与命令的追加造成磁盘上的冲突优点每一次修改都同步默认每秒同步一次可能会丢失一秒的数据从不同步效率最高缺点相对于数据文件来说远远大于修复的速度也比慢运行效率比慢总结持久化方式能够在指定的时间间隔内对你的数据进行快照存储持久化方式记录每次对服务器写的操作当服务器重启的时候回重新执行这些命令来恢复原始数据命令以协议追加保存每次写的操作到文件末尾还能对文件进行后台重写使得文件的体积不至于过大只做缓存如果你只希望你的数据在服务器运行的时候存在你也可以不使用任何持久化同时开启两种持久化方式在这种情况下当重启的时候会优先载入文件来恢复原始的数据因为在通常情况下文件保存的数据集要比文件保存的数据要完整的数据不实时同时使用两者时服务器重启也只会找文件但是更适合用于备份数据库在不断变化不好备份快速重启而且不会又可能潜在的留着作为一个万一的手段性能建议因为文件只用作后备用途建议只在上持久化文件而且只要分钟备份一次就够了值保留这条规则如果好处是在最恶劣情况下也只会地址不超过两秒数据启动脚本较简单只自己的文件就可以了代价以是带来了持续的而是的最后将过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的只要硬盘许可应该尽量减少的频率重写的基础大小默认值太小可以设到以上默认超过原大小大小重写可以改到适当的数值如果不仅靠实现高可用性也可以能省掉一大笔也减少了时带来的系统波动代价是如果同时倒掉会丢失十几分钟的数据启动脚本也要比较两个中的文件载入较新的那个微博就是这种架构持久化的取舍和选择持久化运维常见问题操作同步操作与内存量息息相关内存越大耗时越长与机器类型有关改善优先使用物理机或者高效支持操作的虚拟化技术控制实例最大可用内存合理配置内存分配策略降低频率例如放宽重写自动触发机制时机不必要的全量复制子进程开销和优化开销和文件生成属于密集型优化不做绑定不和密集型部署内存开销内存开销优化硬盘开销和文件写入可以结合分析优化不要和高硬盘负载服务部署在一起存储服务消息队列等根据写入量决定磁盘类型例如单机多实例持久化文件目录可以考虑分盘追加阻塞发布订阅发布订阅是一种消息通信模式发送者发送消息订阅者订阅消息客户端可以订阅任意数量的频道下图展示了频道以及订阅这个频道的三个客户端之间的关系当有新消息通过命令发送给频道时这个消息就会发送给订阅它的三个客户端实例我们打开两个客户端在第一个客户端订阅频道为订阅端结果在第二个客户端发送消息为发送端在订阅端会显示订阅常用命令订阅一个或多个符合给定模式的频道查看订阅与发布系统状态将消息发送到指定的频道返回订阅者数量退订所有给定模式的频道订阅给定的一个或多个频道的信息退订给定的频道原理是使用实现的通过分析源码里的文件可以了解发布与订阅机制的底层实现通过等命令实现发布和订阅功能通过命令订阅某频道后里维护了一个字典字典的键就是一个个而字典的值则是一个链表链表中保存了所有订阅这个的客户端命令的关键就是将客户端添加到给定的订阅链表中通过命令向订阅者发送消息会使用给定的频道作为键在它维护的字典中查找记录了订阅这个频道的所有客户端的链表遍历这个链表将消息发布给所有订阅者从字面上理解就是发布与订阅在中你可以设定对某一个值进行消息发布及消息订阅当一个值上进行了消息发布后所有订阅它的客户端都会收到响应的消息这一功能最明显的语法就是用作实时消息系统连接命令连接命令主要是用于连接服务验证密码是否正确打印字符串查看服务是否运行正常会返回关闭当前连接切换到指定的数据库服务器服务器命令主要是用于管理服务查看是否设置了密码设置密码验证密码客户端连接通过监听一个端口或者的方式来接收来自客户端的连接当一个连接建立后内部会进行以下一些操作首先客户端会被设置为非阻塞模式因为在网络事件处理上采用的是非阻塞多路复用模型然后为这个设置属性禁用算法然后创建一个可读的文件事件用于监听这个客户端的数据发送最大连接数在中最大连接数是被直接硬编码在代码里面的而在版本中这个值变成可配置的的默认值是你也可以在中对这个值进行修改实例以下实例我们在服务启动时设置最大连接数为性能测试性能测试使通过同时执行多个命令实现的性能测试的基本命令注意该命令是在目录下执行实例管道技术是一种基于客户端服务端模型以及请求响应协议的服务这意味着通常情况下一个请求会遵循以下步骤客户端向服务端发送一个查询请求并监听返回通常是以阻塞模式等待服务端响应服务端处理命令并将结果返回给客户端命令个命令操作次个命令时间次网络次命令次网络次命令数据量一条命令条命令的命令时间是微秒级别每次条数要控制网络管道技术可以在服务端未响应时客户端可以继续向服务端发送请求并最终一次性读取所有服务端的响应管道技术显著提高了服务的性能查看管道只需要启动实例并输入以下命令使用建议注意每次携带数据量每次只能作用在一个节点上操作与区别主从复制概念主从复制是指将一台服务器的数据复制到其他的服务器前者称为主节点后者称为从节点数据的赋值是单向的只能由主节点到从节点以写为主以读为主默认情况下每台服务器都是主节点且一个主节点可以有多个从节点或没有从节点但一个从节点只能有一个主节点主从复制的作用包括数据冗余主从复制实现了数据的热备份是持久化之外的一种数据冗余方式故障恢复当主节点出现问题时可以由从节点提供服务实现快速的故障恢复实际上是一种服务的冗余负载均衡在主从复制的基础上配合读写分离可以由主节点提供写服务由从节点提供读服务即写数据时应用连接主节点读数据时应用连接从节点分担服务器负载尤其在写少读多的场景下通过多个从节点分担负载可以大大提高服务器的并发量高可用基石除了上述作用外主从复制还是哨兵和机群能实施的基础一次说主从复制是高可用性的基础一般来说要将运用于工程项目中只使用一台是不可能的宕机一主二从因为从结构上单个服务器会发生单点故障并且一台服务器需要处理所有的请求负载压力较大从容量上单个服务器内存容量有限就算一台服务器内存容量为也不能将所有内存用作存储内存一般来说单台最大使用内存不应该超过基础环境配置查看当期库的信息角色没有从机在一台机器模拟主从需要开启三个服务则需要三个配置文件且相对于的服务的配置文件要进行相应的修改对应的端口号要改后台服务要开启后台进程文件修改日志文件配置持久化文件修改一主二从配置只配置从机不用配置主机在从机中使用此命令指认主机也可以在配置文件中配置此命令设置主机命令可以在从节点断开主节点连接配置从节点只读细节主机可以写从机只能读主机中的所有信息和数据都会被自动保存在从机当没有配置哨兵而主机挂了的时候从机任然是从机除非手动修改配置只要一变成从机立马就会从主机中拿到数据赋值原理启动成功连接到后会发送一个同步命令接到命令启动后台的存盘进程同时收集所有接受到的用于修改数据集命令在后台进程执行完毕之后将传送整个数据文件到并完成一次同步全量复制而服务在接受到数据库文件数据后将其存盘并加载到内存中增量复制继续将新的所有收集到的修改命令依次传给完成同步但是只要是重新连接一次完全同步全量复制将被自动执行全量复制开销时间文件网络传输时间从节点清空数据时间从节点加载的时间可能的重写时间主从可以有多种模式同步模式在同步模式下主节点在写入数据后等待所有从节点确认接收到数据然后再向客户端发送成功响应这确保了数据在主从节点之间的一致性但也可能导致一些性能开销尤其是在从节点与主节点之间的网络延迟较大时异步模式在异步模式下主节点将写入的数据立即返回给客户端而不等待从节点确认从节点会在后台异步地复制主节点的数据这种模式可以提高写入性能但在某些情况下可能导致主从节点之间的数据稍有延迟半同步模式半同步模式是同步模式和异步模式的一种折中主节点等待至少一个从节点确认接收到数据后才响应客户端这种方式在一定程度上保持了一致性并减少了一些异步模式的延迟无磁盘复制在无磁盘复制模式下从节点不会将复制的数据写入磁盘而是直接保存在内存中这可以提高从节点的复制性能但在从节点重启时会导致数据丢失断点续传引入了断点续传功能允许从节点在复制时断开连接然后在网络重新连接后继续从断点处进行复制而不是重新开始这可以提高复制的可靠性运维中常见问题读写分离复制数据延迟从节点故障主从配置不一致例如不一致丢失数据例如数据结构优化参数内存不一致规避全量复制第一次全量复制不可避免小主节点低峰节点运行不匹配主节点重启运行变化故障转移例如哨兵或集群复制积压缓冲区不足网络中断部分复制无法满足增大复制缓冲区配置网络增强规避复制风暴单节点复制风暴问题主节点重启多从节点复制解决更换复制拓扑架构自动选举老大的模式概述主从切换技术的方法是当主服务器宕机后需要手动把一台从服务器切换为主服务器这就需要人工干预费时费力还会造成一段时间内服务不可用所以从开始正式提供了哨兵架构来解决这个问题哨兵能够自动监控主机是否故障如果故障了根据投票数自动将从库转换成主库作用步骤多个发现并确认有问题选举除一个作为领导选出一个作为通知其他成为新的的通知客户端主从变化等待老的复活成为新的哨兵模式是一种特殊的模式首先提供了哨兵的命令哨兵是一个独立的进程作为进程它会独立运行其原理是哨兵通过发送命令等待服务器响应从而监控运行的多个实例这里哨兵有两个作用通过发送命令让服务器返回监控其运行状态包括主服务器和从服务器当哨兵监测到宕机会自动将切换成然后通过发布订阅模式通知其他的从服务器修改配置文件让它们切换主机然而一个哨兵进程对服务器进行监控可能会出现问题为此我们可以使用多个哨兵进行监控各个哨兵之间还会进行监控这样就形成了多哨兵模式假设服务器宕机哨兵先检测到这个结果系统并不会马上进行过程仅仅是哨兵主观的认为主服务器不可用这个现象称为主观下线当后面的哨兵也检测到主服务器不可用并且数量达到一定值时那么哨兵之间就会进行一次投票投票算法投票的结果由一个哨兵发起进行故障转移操作切换成功后就会通过发布订阅模式让各个哨兵把自己监控的从服务器实现切换主机这个过程称为客观下线三个定时任务每每个对和执行发现节点确认主从关系每每个通过节点的交换信息通过频道交互交互对节点的看法和自身信息每每个对其他和执行心跳检测失败判定依据哨兵启动步骤哨兵环境配置在安装目录下新建哨兵实例运行的端口默认哨兵的工作目录配置守护进程启动和日志哨兵监控的主节点的可以自己命名的主节点名字只能由字母数字这三个字符组成配置多少个哨兵统一认为主节点失联那么这时客观上认为主节点失联了当在实例中开启了授权密码这样所有连接实例的客户端都要提供密码设置哨兵连接主从的密码注意必须为主从设置一样的验证密码指定多少毫秒之后主节点没有应答哨兵此时哨兵主观上认为主节点下线默认秒这个配置项指定了在发生主备切换时最多可以有多少个同时对新的进行同步这个数字越小完成所需的时间就越长但是如果这个数字越大就意味着越多的因为而不可用可以通过将这个值设为来保证每次只有一个处于不能处理命令请求的状态故障转移的超时时间可以用在以下这些方面同一个对同一个两次之间的间隔时间当一个从一个错误的那里同步数据开始计算时间直到被纠正为向正确的那里同步数据时当想要取消一个正在进行的所需要的时间当进行时配置所有指向新的所需的最大时间不过即使过了这个超时依然会被正确配置为指向但是就不按所配置的规则来了默认三分钟配置当某一事件发生时所需要执行的脚本可以通过脚本来通知管理员例如当系统运行不正常时发邮件通知相关人员对于脚本的运行结果有以下规则若脚本执行后返回那么该脚本稍后将会被再次执行重复次数目前默认为若脚本执行后返回或者比更高的一个返回值脚本将不会重复执行如果脚本在执行过程中由于收到系统中断信号被终止了则同返回值为时的行为相同一个脚本的最大执行时间为如果超过这个时间脚本将会被一个信号终止之后重新执行通知型脚本当有任何警告级别的事件发生时比如说实例的主观失效和客观失效等等将会去调用这个脚本这时这个脚本应该通过邮件等方式去通知系统管理员关于系统不正常运行的信息调用该脚本时将传给脚本两个参数一个是事件的类型一个是事件的描述如果配置文件中配置了这个脚本路径那么必须保证这个脚本存在于这个路径并且是可执行的否则无法正常启动成功通知脚本客户端重新配置主节点参数脚本当一个由于而发生改变时这个脚本将会被调用通知相关的客户端关于地址已经发生改变的信息以下参数将会在调用脚本时传给脚本目前总是是或者中的一个参数是用来和旧的和新的即旧的通信的这个脚本应该是通用的能被多次调用不是针对性的启动哨兵配置文件路径优点哨兵集群基于主从复制模式所有的主从配置优点都有主从可以切换故障可以转移系统的可用性就会更好哨兵模式就是主从模式的升级手动到自动更加健壮缺点不好在线扩容集群容量一旦到达上限在线扩容会十分麻烦实现哨兵模式的配置其实是很麻烦的里面有很多选择节点运维问题节点下线机器下线例如过保等情况机器性能不足例如内存硬盘网络等节点自身故障例如服务不稳定等从节点临时下线还是永久下线例如是否做一些清理工作但是要考虑读写分离情况节点同上节点上线主节点进行替换从节点即可节点可以感知节点参考其他节点启动即可总结是的高可用实现方案故障发现故障自动转移配置中心客户端通知从版本开始使用尽可能在不同物理机上部署所有节点中的节点个数应该大于等于三且最好为奇数中的数据节点与普通数据节点没有区别客户端初始化时连接的是节点集合不再是具体的节点但只是配置中心不是代理实现读写分离高可用可以依赖节点的消息通知获取数据节点的状态变化为什么需要集群需要更高的并发量需要更多的数据量数据分布顺序分区和哈希分区哈希分布节点取余分区当采用节点取模时如果节点扩容了会导致数据大规模迁移所以采用节点取模时扩容最好采用多倍扩容增加原节点数的倍数这能有效减低数据迁移一致性哈希分区客户端分片哈希顺时针优化取余当采用此方法时扩容只会导致一个临近节点的数据迁移翻倍伸缩保证最小迁移数据和负载均衡虚拟槽分区预设虚拟槽每个槽映射一个数据子集一般比节点数大良好的哈希函数例如服务端管理节点槽数据例如架构单机架构分布式架构节点启动集群模式所有节点共享消息指派槽客户端只需计算特性复制高可用分片安装原生命令安装配置开启节点开启集群模式超时时间集群配置文件是否全部节点都提供服务才认为集群正常工作指派槽主从相关命令查看信息查看节点信息官方工具安装环境准备下载编译安装安装安装使用配置集群开启服务一键开启每个主节点有几个从节点总结原生命令安装理解架构生产环境不使用官方工具安装高效准确生产环境可以使用其他可视化部署集群伸缩集群伸缩原理集群伸缩槽和数据在节点之间的移动扩容集群准备新节点集群模式配置与其他节点统一启动后是孤儿节点加入集群作用为它迁移槽和数据实现扩容作为从节点负责故障转移迁移槽和数据槽迁移计划迁移数据指定任意一个节点即可它首先会提示需要迁移多个槽接着它会提示需要将槽迁移到哪个节点这里必须写节点紧跟着它会提示槽从哪些节点中迁出如果指定为则待迁移的槽在剩余节点中平均分配在这里和各迁移个槽出来也可从指定节点中迁出这个时候必须指定源节点的节点最后以结束添加从节点收缩集群下线迁移槽忘记节点关闭节点客户端路由重定向重定向和两者都是客户单重定向槽已经确定迁移槽还在迁移中客户端追求性能客户端从集群中选一个可运行节点使用初始化槽和节点映射将的结果映射到本地准备执行命令如何实现批量操作所有必须在一个槽四种批量优化的方法串行使用循环遍历每个操作串行将操作分组分好组以后只需要执行对应集群节点数的并行将操作分组分好组以后开启多线程进行操作对进行包装保证所有在一个节点故障转移故障发现通过消息实现故障发现不需要主观下线定义某个节点认为另一个节点不可用客观下线当半数以上持有槽的主节点都编辑某节点主观下线故障恢复资格检查每个从节点检查与故障主节点的短线时间超过取消资格默认是准备选举时间选举投票替换主节点当前从节点取消复制变为主节点执行撤销故障主节点负责的槽并执行把这些槽分配给自己向集群广播自己的消息表明已经替换了故障从节点常见问题集群完整性默认为集群中个槽全部可用保证集群完整性节点故障或者正在故障转移大多数业务无法容忍建议设置为带宽消耗消息发送频率节点发现与其他节点最后通信时间超过时会直接发送消息消息数据量槽数组空间和整个集群的状态数据个节点状态数据约节点部署的机器规模集群分布的机器越多且每台机器划分的节点数约均匀则集群内整体的可用带宽越高优化避免大集群避免多业务使用一个集群大业务可用多集群带宽和故障转移速度的均衡尽量均匀分配到多机器上保证高可用和带宽广播问题在集群中每个节点广播加重带宽解决单独走一套集群倾斜数据倾斜内存不均节点和槽分配不均不同槽对应的键值数量差异较大包含内存相关配置不一致请求倾斜热点集群读写分离只读模式集群模式的从节点不接受任何读请求重定向到负责槽的主节点命令可以读连接级别命令读写分离更加复杂同样的问题复制延迟读取过期数据从节点故障修改客户端不建议在集群模式下使用读写分离数据迁移集群单机集群总结缓存缓存的收益与成本收益加速读写通过缓存加速读写速度加速硬盘读写浏览器缓存缓存数据库结果降低后端负载后端服务器通过前端缓存降低负载业务端使用降低后端负载等成本数据不一致缓存层和数据层有时间窗口不一致和更新策略有关代码维护成本多了一层缓存逻辑运维成本例如使用场景降低后端负载对高消耗的结果集分组统计结果缓存加速请求响应利用优化响应时间大量写合并为批量写如计数器先累加再批量写缓存更新策略算法剔除例如超时剔除例如主动更新开发控制生命周期缓存更新建议底一致性最大内存和淘汰策略高一致性超时剔除和主动更新结合最大内存和淘汰策略兜底缓存粒度控制通用性全量属性更好占用空间部分属性更好代码维护表面上全量属性更好缓存穿透缓存的使用极大的提升了应用程序的性能和效率特别是数据查询方面但同时它也带来了一些问题其中最重要的问题就是数据的一致性问题从严格意义上讲这个问题无解如果对数据的一致性要求很高那么就不能使用缓存另外一些典型问题就是缓存穿透缓存雪崩和缓存击穿概念缓存穿透的概念很简单用户想要查询一个数据发现内存数据库没有也就是缓存没有命中于是向存储层数据库查询发现也没有于是本次查询失败当用户很多的时候缓存都没有命中于是都去请求了存储层数据库这会给存储层数据库造成很大的压力这时候就相当于出现了缓存穿透原因业务代码自身问题恶意攻击爬虫等如何发现业务的相应时间业务本身问题相关指标中调用书缓存层命中数存储层命中数解决方案布隆过滤器布隆过滤器是一种数据结构对所有可能查询的参数以形式存储在控制层先进行校验不符合则丢弃从而避免了对底层存储系统的查询压力缓存空对象当存储层不命中后即使返回的空对象也将其缓存起来同时会设置一个过期时间之后再访问这个数据将会从缓存中或区域保护了后端数据源但是这种方法会存在两个问题如果空值能被缓存起来这就意味着缓存需要更多的空间存储更多的键意味着当中可能会有很多的空值的键即使对空值设置了过期时间还是会存在缓存层和存储层的数据会有一点时间窗口的不一致着对于需要保持一致性的业务会有影响缓存击穿概述这里需要注意和缓存穿透的区别缓存击穿是指一个非常热点在不停的杠着大并发大并发集中对着一个点进行访问当这个在失效的瞬间持续的大并发就穿破缓存直接请求数据库就像在屏障上凿开了一个洞当某个在过期的瞬间有大量的请求并发访问这类数据一般是热点数据由于缓存过期会同时访问数据库来查询最新数据并且回写缓存会导致数据库瞬间压力过大解决方案设置热点数据永不过期从缓存层面来看没有设置过期时间所以不会出现热点过期后产生的问题加互斥锁分布式锁使用分布式锁保证对于每个同时只有一个线程去查询后端服务其他线程没有获得分布式锁的权限一次只需要等待即可这种方式将高并发的压力转移到了分布式锁因此对分布式锁的考验很大缓存雪崩概念缓存雪崩是指在某一个时间段缓存集中过期失效或由于服务承载大量请求当服务异常脱机流量直接压向后端组件造成级联故障产生雪崩的原因之一比如在写文本的时候马上就要到双十二零点很快就会迎来一波抢购这波商品时间比较集中的放入了缓存假设缓存一小时那么到了凌晨一点钟的时候这批商品的缓存就都过期了而这对这批商品的访问查询都落到了数据库上对于数据库而言就会产生周期性的压力波峰于是所有的请求都会达到存储层存储层的调用量会暴增造成存储层也会挂掉的情况其实集中过期倒不是非常致命比较致命的缓存雪崩是缓存服务器某个节点宕机或断网因为自然形成的缓存雪崩一定是在某个时间段集中创建缓存这个时候数据库也是可以顶住压力的无非就是对数据库产生周期性的压力而已而缓存服务节点宕机对数据库造成的压力是不可预知的很有可能瞬间就把数据库压垮解决方案高可用这个思想的含义是既然有可能挂掉那我多增设几台这样一台挂掉之后其他的还可以继续工作其实就是搭建的集群限流降级这个解决方案的思想是在缓存失效后通过加锁或者队列来控制读数据库写缓存的线程数量比如对某个只允许一个线程查询数据和写缓存其他线程等待数据预热数据加热的含义就是在正式部署之前我先把可能会访问的数据先预先访问一边这样部分可能大量访问的数据就会加载到缓存中在即将发送大并发访问前手动除法加载缓存不同的设置不同的过期时间让缓存失效的时间尽量均匀无底洞问题加机器性能没有提升反而下降了优化命令本身优化例如慢查询减少网络通信次数降低接入成本例如客户端长连接连接池等热点重建优化三个目标减少重建缓存的次数数据尽可能一致减少潜在危险两个解决互斥锁永不过期缓存层面没有设置过期时间功能层面为每个添加逻辑过期时间但发现超过逻辑过期时间后会使用单独的线程去构建缓存云平台规模化困扰遇到的问题发布构建繁琐私搭乱盖节点机器等运维成本监控报警初级一键开启机器应用实例监控和报警客户端透明使用性能上报可视化运维配置扩容机器应用实例上下线已经存在直接接入和数据迁移开源地址使用场景全量视频缓存视频播放跨机房高可用消息队列同步中间件分布式布隆过滤器百万计数系统计数播放量其他排行榜社交直播实时计算反作弊等基于的分布式布隆过滤器现在有亿个电话号码现有万个电话号码要快速准确判断这些电话号码是否已经存在通过数据库查询实现快速有点难数据预防在集合中亿字节内存浪费准确有点难应用场景垃圾邮件过滤文字处理软件错误单词检测网络爬虫重复检测行过滤布隆过滤器原理误差率与与误差率成反比与误差率成正比布隆过滤器开发规范键值设计设计设计拒绝危害网络阻塞集群节点数据不均衡阻塞频繁序列化应用服务器消耗发现应用异常主动报警网络流量监控客户端监控内核热点问题优化删除选择合适的数据结构过期设计命令优化客户端优化内存管理内存优化内存消耗内存管理内存优化内存消耗内存使用统计内存消耗划分使用命令可以查看全部客户端状态复制缓冲区缓冲区对象内存内存碎片子进程内存消耗内存管理设置内存上限动态调整内存上限内存回收策略删除过期键值内存溢出策略内存优化一次内存暴增客户端溢出总结开发运维常见坑内核优化进程的对时器文件句柄数最好为最大句柄数因为除了客户端连接外本身也需要句柄握手队列安全的热点寻找方法客户端代理服务端机器端的客户端官方提供的各种语言的客户端在这里选择下载下载完成后在中即可使用使用连接提供两个类和用于实现的命令用于大部分官方的命令并使用官方的语法和命令是的子类添加获取连接池使用来管理对一个的所有连接避免每次建立释放连接的开销默认每个实例都会维护一个自己的连接池可以直接建立一个连接池然后作为参数这样就可以实现多个实例共享一个连接池管道默认在执行每次请求都会创建连接池申请连接和断开归还连接池一次连接操作如果想要在一次请求中指定多个命令可以使用实现一次请求多个命令并且默认情况下一次是原子性操作开启管道并实例化管道对象执行操作发布与订阅定义一个发布与订阅类定义名称定义发布方法定义订阅方法发布端发布订阅端获取发布的信息哨兵使用进行写的操作使用进行读的操作集群写入值获取值',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-23 16:41:54',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="AYO" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://git.yuki.love/" title="AYO网站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="AYO网站"/><span class="back-menu-item-text">AYO网站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/3708003152300183" title="AYO博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="AYO博客"/><span class="back-menu-item-text">AYO博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/AYO-Al" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">AYO</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Database/" style="font-size: 1.05rem;">Database<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-02-17T02:05:14.289Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-01-23T08:41:54.435Z" title="更新于 2024-01-23 16:41:54">2024-01-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">18.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/preview.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/"><header><h1 id="CrawlerTitle" itemprop="name headline">无题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">AYO</span><time itemprop="dateCreated datePublished" datetime="2024-02-17T02:05:14.289Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time><time itemprop="dateCreated datePublished" datetime="2024-01-23T08:41:54.435Z" title="更新于 2024-01-23 16:41:54">2024-01-23</time></header><h2 id="1-什么是Redis？"><a href="#1-什么是Redis？" class="headerlink" title="1.什么是Redis？"></a>1.什么是Redis？</h2><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务，是一个基于内存的键值型NOSQL数据库，基于c语言编写</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性(redis6.0只有对网络请求处理才是多线程)</li>
<li>低延迟，熟读快(基于内存，IO多路复用，良好的编码)</li>
<li>支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li>
<li>支持数据的备份，即master-slava模式的数据备份</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
<li>开源</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><p>支持多种语言的客户端</p>
</li>
<li><p>性能极高-Redis读数据的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s </p>
</li>
<li><p>丰富的数据类型</p>
</li>
<li><p>原子-Redis的所有操作都是原子性的，意思是要么执行成功要么完全失败。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</p>
</li>
<li><p>丰富的特性-Redis还支持publish&#x2F;subscribe，通知，key过期等等特性</p>
</li>
</ul>
<h3 id="1-1-认识NOSQL"><a href="#1-1-认识NOSQL" class="headerlink" title="1.1.认识NOSQL"></a>1.1.认识NOSQL</h3><p>​																				<strong>SQL与NOSQL的对比</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">SQL</th>
<th align="center">NOSQL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据结构</td>
<td align="center">结构化(Structured)</td>
<td align="center">非结构化</td>
</tr>
<tr>
<td align="center">数据关联</td>
<td align="center">关联的(Relational)</td>
<td align="center">非关联的</td>
</tr>
<tr>
<td align="center">查询方式</td>
<td align="center">SQL查询</td>
<td align="center">非SQL</td>
</tr>
<tr>
<td align="center">事务特性</td>
<td align="center">ACID</td>
<td align="center">BASE</td>
</tr>
<tr>
<td align="center">存储方式</td>
<td align="center">磁盘</td>
<td align="center">内存</td>
</tr>
<tr>
<td align="center">扩展性</td>
<td align="center">垂直</td>
<td align="center">水平</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">1.数据结构固定               2.相关业务对数据安全性、一致性要求较高</td>
<td align="center">1.数据结构不固定      2.对一致性、安全性要求不高      3.对性能高</td>
</tr>
</tbody></table>
<h3 id="1-2-Redis应用场景"><a href="#1-2-Redis应用场景" class="headerlink" title="1.2.Redis应用场景"></a>1.2.Redis应用场景</h3><ul>
<li>缓存系统</li>
<li>计数器</li>
<li>消息队列系统</li>
<li>排行榜</li>
<li>社交网络</li>
<li>实时系统</li>
</ul>
<h2 id="2-Redis学习准备"><a href="#2-Redis学习准备" class="headerlink" title="2.Redis学习准备"></a>2.Redis学习准备</h2><p>Redis官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>Redis在线测试：<a target="_blank" rel="noopener" href="http://try.redis.io/">http://try.redis.io/</a></p>
<p>Redis命令参考：<a target="_blank" rel="noopener" href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p>
<h3 id="2-1-Redis在Windows安装"><a href="#2-1-Redis在Windows安装" class="headerlink" title="2.1.Redis在Windows安装"></a>2.1.Redis在Windows安装</h3><p>​	<a target="_blank" rel="noopener" href="https://redis.io/">Redis官网</a>：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io</a></p>
<ul>
<li><p>redis-cli：是redis提供的命令行客户端</p>
</li>
<li><p>redis-server：是redis的服务端启动脚本</p>
</li>
<li><p>redis-benchmark：Redis性能测试工具</p>
</li>
<li><p>redis-check-aof：AOF文件修复工具</p>
</li>
<li><p>redis-check-dump：RDB文件检查工具</p>
</li>
<li><p>redis-sentinel：是redis的哨兵启动脚本</p>
</li>
<li><p>ping：测试连接，在连接redis后，输出该命令返回PONG则连接成功</p>
</li>
</ul>
<h3 id="2-2-Redis在Linux安装"><a href="#2-2-Redis在Linux安装" class="headerlink" title="2.2.Redis在Linux安装"></a>2.2.Redis在Linux安装</h3><ol>
<li>下载压缩包：wget <a target="_blank" rel="noopener" href="https://download.redis.io/releases/redis-3.0.7.tar.gz">https://download.redis.io/releases/redis-3.0.7.tar.gz</a></li>
<li>解压：tar -xvf redis-stable.tar.gz</li>
<li>创建软链接：ln -s redis-stable redis</li>
<li>编译：make</li>
<li>安装：make install</li>
</ol>
<blockquote>
<p>Redis三种启动方式</p>
</blockquote>
<ol>
<li>最简启动<ol>
<li>redis-server</li>
</ol>
</li>
<li>动态参数启动<ol>
<li>redis-server –port 6390</li>
</ol>
</li>
<li>配置文件启动<ol>
<li>redis-server configPath</li>
</ol>
</li>
</ol>
<blockquote>
<p>三种启动方式比较</p>
</blockquote>
<ol>
<li>生产环境选择配置启动</li>
<li>单机多实例配置文件可以用端口区分开</li>
</ol>
<blockquote>
<p>Redis客户端返回值</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7is4h.png" alt="image-20230202145121778"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ix2z.png" alt="image-20230202145149259"></p>
<h3 id="2-3-配置文件配置"><a href="#2-3-配置文件配置" class="headerlink" title="2.3.配置文件配置"></a>2.3.配置文件配置</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yrq5dx-0.png" alt="image-20230307205206866"></p>
<h3 id="2-3-Redis客户端"><a href="#2-3-Redis客户端" class="headerlink" title="2.3.Redis客户端"></a>2.3.Redis客户端</h3><p>安装完后，我们就可以操作Redis，实现数据的CRUD了。这需要用到客户端，包括：</p>
<ul>
<li>命令行客户端</li>
<li>图形化桌面客户端</li>
<li>编程客户端</li>
</ul>
<h4 id="2-3-1-命令行客户端"><a href="#2-3-1-命令行客户端" class="headerlink" title="2.3.1.命令行客户端"></a>2.3.1.命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redi-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>:指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>:指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123</code>:指定redis的访问密码</li>
</ul>
<p>其中commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>:与redis服务器做心跳测试，服务器正常会返回<code>pong</code></li>
</ul>
<h4 id="2-3-2-图形化桌面客户端"><a href="#2-3-2-图形化桌面客户端" class="headerlink" title="2.3.2.图形化桌面客户端"></a>2.3.2.图形化桌面客户端</h4><p><a href="%5BRedisDesktopManager%5D(https://github.com/uglide/RedisDesktopManager/releases/tag/2022.4.2)">RedisDesktopManager</a>:github大神编写的客户端，直接下载安装就能用</p>
<h2 id="3-Redis数据结构"><a href="#3-Redis数据结构" class="headerlink" title="3.Redis数据结构"></a>3.Redis数据结构</h2><p>Redis是一个key-value的数据库，key一般是hiString类型，不过value的类型多种多样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yrle7j-0.png" alt="image-20230307210217443"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7is9y.png" alt="image-20230202160605409"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yu0jjb-0.png" alt="image-20230307210624741"></p>
<h3 id="3-1-key通用命令"><a href="#3-1-key通用命令" class="headerlink" title="3.1.key通用命令"></a>3.1.key通用命令</h3><ol>
<li><p>help [command]：查看一个命令的具体用法</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KEYS pattern</span><br><span class="line"> summary: Find all keys matching the given pattern</span><br><span class="line"> since: 1.0.0</span><br><span class="line"> group: generic</span><br><span class="line"> <span class="built_in">return</span>：符合条件的值</span><br><span class="line"><span class="comment"># 具体模板可以去官网查看</span></span><br><span class="line"><span class="comment"># 不建议在生产环境中使用</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DEL key [key ...]</span><br><span class="line"> summary: Delete a key</span><br><span class="line"> since: 1.0.0</span><br><span class="line"> group: generic</span><br><span class="line"> <span class="built_in">return</span>：删除的元素数量，删除不存在的元素不计算在内</span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EXISTS key</span><br><span class="line">summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br><span class="line"><span class="built_in">return</span>：有返回1，无返回0</span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EXPIRE key seconds</span><br><span class="line">summary: Set a key<span class="string">&#x27;s time to live in seconds</span></span><br><span class="line"><span class="string">since: 1.0.0</span></span><br><span class="line"><span class="string">group: generic</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DBSIZE</span><br><span class="line"> summary: 计算key总数</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TTL key(persist key 可以去掉过期时间)</span><br><span class="line">summary: Get the time to live <span class="keyword">for</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br><span class="line"><span class="built_in">return</span>：key过期后返回-2，-1代表永久有效</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>keys</td>
<td>O(n)</td>
</tr>
<tr>
<td>dbsize</td>
<td>O(1)</td>
</tr>
<tr>
<td>del</td>
<td>O(1)</td>
</tr>
<tr>
<td>exists</td>
<td>O(1)</td>
</tr>
<tr>
<td>expire</td>
<td>O(1)</td>
</tr>
<tr>
<td>type</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/ytbjqu-0.png" alt="image-20230307210507394"></p>
</li>
</ol>
<h3 id="3-2-key的层级结构"><a href="#3-2-key的层级结构" class="headerlink" title="3.2.key的层级结构"></a>3.2.key的层级结构</h3><p>Redis没有类似MYSQL中的Table的概念，我们该如何区分不同类型的key呢</p>
<ul>
<li><p>例如需要存储用户，商品信息到redis，用户id是1，商品id也是1</p>
</li>
<li><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<blockquote>
<p>项目名:业务名:类型:id</p>
<p>例如项目名称叫heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<p>user：heima:user:1</p>
<p>product：heima:product:1</p>
<p>设置数据时： SET heima:user:1 “{‘id’:1, ‘name’:’jack’, ‘age’:21}”</p>
<p>这样多插入几个后，会在Redis中形成层级结构</p>
</blockquote>
</li>
</ul>
<h3 id="3-3-String类型"><a href="#3-3-String类型" class="headerlink" title="3.3.String类型"></a>3.3.String类型</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型</p>
<p>其value是字符串，不过根据字符串的格式不同，又分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增自减</li>
<li>float：副段类型，可以做自增自减</li>
</ul>
<p><strong>不管是那种，底层都是字节数组形式存储，之不贵是编码方式不同。字符串类型的最大空间不能超过512m</strong></p>
<p><strong>String结构是将对象序列化为JSON字符串后存储，当需要修改对象的某个字段时很不方便</strong></p>
<h4 id="3-3-1-String常用命令"><a href="#3-3-1-String常用命令" class="headerlink" title="3.3.1.String常用命令"></a>3.3.1.String常用命令</h4><ul>
<li><p>SET：添加或者修改已经存在的String类型的键值对</p>
</li>
<li><p>GET：根据key获取String类型的value</p>
</li>
<li><p>MSET：批量添加对个String类型的键值对(O(n))</p>
</li>
<li><p>MGET：根据对个key获取多个String类型的value(O(n))</p>
</li>
<li><p>INCR：让一个整型的key自增1</p>
</li>
<li><p>INCRBY：让一个整型的key自增并指定步长</p>
</li>
<li><p>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</p>
</li>
<li><p>SETNX：添加一个string类型的键值对，前提是这个key不存在，否则不执行</p>
</li>
<li><p>SETEX：添加一个string类型的键值对，并且指定有效期</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yv7qta-0.png" alt="image-20230307210825074"></p>
<h3 id="3-4-Hash类型"><a href="#3-4-Hash类型" class="headerlink" title="3.4.Hash类型"></a>3.4.Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于java中的HashMap结构</p>
<p>Hash是Redis中一个string类型的field(字段)和value(值)的映射表，hash特别适合用于存储对象，每个hash可以存储2^32 -1个键值对</p>
<p>Hash结构可以将对象中的每个字段独立存储，可与针对单个字段做CRUD</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/image-20220812110924292.png" alt="image-20220812110924292"></p>
<h4 id="3-4-1-Hash常见命令"><a href="#3-4-1-Hash常见命令" class="headerlink" title="3.4.1.Hash常见命令"></a>3.4.1.Hash常见命令</h4><ul>
<li>HSET KEY FIELD VALUE：添加或者修改hash类型key的field的值</li>
<li>HGET KEY FIELD：获取一个hash类型key的field的值</li>
<li>HMSET ：批量添加多个hash类型key的field的值</li>
<li>HMGET：批量获取对个hash类型key的field的值</li>
<li>HGETALL：获取一个hash类型的key中的所有field和value</li>
<li>HKEYS：获取一个hash类型key中的所有field</li>
<li>HVALS：获取一个hash类型的key中的所有value</li>
<li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yvdqnx-0.png" alt="image-20230307210853259"></p>
<h3 id="3-5-List类型"><a href="#3-5-List类型" class="headerlink" title="3.5.List类型"></a>3.5.List类型</h3><p>Redis中的List类型与java中的LinkedList类似，可以看做是一个双向链表结构。支持正向检索也可以支持反向检索</p>
<p>一个列表最多可以包含2^32-1个元素</p>
<p>特征：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ivgw.png" alt="image-20230202174633999"></p>
<h4 id="3-5-1-List常用命令"><a href="#3-5-1-List常用命令" class="headerlink" title="3.5.1.List常用命令"></a>3.5.1.List常用命令</h4><ul>
<li>LPUSH KEY ELEMENT…:向列表左侧插入一个或多个元素</li>
<li>LPOP KEY：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH KEY ELEMENT…：向列表右侧插入一个或多个元素</li>
<li>RPOP KEY：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>LRANGE KEY STAT END：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yvspjr-0.png" alt="image-20230307210923684"></p>
<h3 id="3-6-set类型"><a href="#3-6-set类型" class="headerlink" title="3.6.set类型"></a>3.6.set类型</h3><p>Redis的Set结构与java中的HashSet类型，可以看做是一个以value为null的HashMap。也是一个hash表，因此具备与HashSet类似的特征：</p>
<p>Redis中set最多可以为2^32 -1</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集。差集等功能</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7itw4.png" alt="image-20230202174655829"></p>
<h4 id="3-6-1-Set常见命令"><a href="#3-6-1-Set常见命令" class="headerlink" title="3.6.1.Set常见命令"></a>3.6.1.Set常见命令</h4><ul>
<li>SADD key member…:向set中添加一个或多个元素</li>
<li>SREM key member…:移除set中的指定元素</li>
<li>SCARD key：返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在与set中</li>
<li>SMEMBERS key：获取set中所有的元素</li>
<li>SINTER key1 key2…:求多个List的交集</li>
<li>SDIFF key1 key2….:求多个List的差集</li>
<li>SUNION key1 key2….:求多个List的并集</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yw9o7z-0.png" alt="image-20230307211002379"></p>
<h3 id="3-7-SortedSet类型"><a href="#3-7-SortedSet类型" class="headerlink" title="3.7.SortedSet类型"></a>3.7.SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于对score属性对元素排序，底层的实现是一个跳表加hash表。特性如下：</p>
<ul>
<li>可排序</li>
<li>元素不可重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序性，<strong>经常被用来实现排行榜这样的功能</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ivok.png" alt="image-20230202174538734"></p>
<h4 id="3-7-1-SortedSet类型常用命令"><a href="#3-7-1-SortedSet类型常用命令" class="headerlink" title="3.7.1.SortedSet类型常用命令"></a>3.7.1.SortedSet类型常用命令</h4><ul>
<li>ZADD key score member…:添加一个或多个元素到SortedSet，如果已经存在则更新其score值</li>
<li>ZREM key member:删除SortedSet中的一个指定元素</li>
<li>ZSORE key member:获取SortedSet指定元素的score值</li>
<li>ZRANK key member:获取SortedSet中指定元素的排名</li>
<li>ZCARD key:获取SortedSet中的元素个数</li>
<li>ZCOUNT key min max:统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member:让SortedSet中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max:按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max:按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>所有默认排序全为<code>升序排序</code>，若要降序，则在命令的Z后面加<code>REV</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/ywfq1n-0.png" alt="image-20230307211031673"></p>
<h3 id="3-8-geospatial-地理位置"><a href="#3-8-geospatial-地理位置" class="headerlink" title="3.8.geospatial 地理位置"></a>3.8.geospatial 地理位置</h3><p>Redis GEO主要用于存储地理位置信息，并对存储的信息进行操作</p>
<p>有效的经度从-180度到180度。</p>
<p>有效的纬度从-85.05112878度到85.05112878度。</p>
<p>当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p>
<p><strong>内部使用的类型为sortedset</strong></p>
<h4 id="3-8-1-GEO常见操作"><a href="#3-8-1-GEO常见操作" class="headerlink" title="3.8.1.GEO常见操作"></a>3.8.1.GEO常见操作</h4><ul>
<li>geoadd：添加地理坐标的位置</li>
<li>geopos：获取地址位置的坐标</li>
<li>geodist：计算两个位置之间的距离</li>
<li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li>
<li>georadiusbymember：根据存在位置集合里面的某个地点获取指定范围内的地理位置集合</li>
<li>geohash：返回一个或多个位置对象的geohash值</li>
</ul>
<p><strong>geoadd</strong></p>
<p>geoadd用于存储指定的地理空间位置，可以将一个或者多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的key中</p>
<p>geoadd语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure>

<p><strong>实例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geoadd china:city 106.50 29.53 chongqin 114.05 22.52 shengzheng</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p><strong>geopos</strong></p>
<p>geopos用于从给定的key里返回所以指定名称的位置，不存在返回nil</p>
<p>geopos语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEOPOS key member [member ...]</span><br></pre></td></tr></table></figure>

<p><strong>实例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> geopos china:city shengzheng shanghai beijin</span><br><span class="line">1) 1) &quot;114.04999762773514&quot;</span><br><span class="line">   2) &quot;22.520000087950386&quot;</span><br><span class="line">2) 1) &quot;121.47000163793564&quot;</span><br><span class="line">   2) &quot;31.229999039757836&quot;</span><br><span class="line">3) 1) &quot;116.39999896287918&quot;</span><br><span class="line">   2) &quot;39.900000091670925&quot;</span><br></pre></td></tr></table></figure>

<p><strong>geodist</strong></p>
<p>geodist用于返回两个给定位置之间的距离</p>
<p>geodist语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></figure>

<p>最后一个距离单位参数说明：</p>
<ul>
<li>m：米，默认单位</li>
<li>km：千米</li>
<li>mi：英里</li>
<li>ft：英尺</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geodist china:city beijin shanghai km</span><br><span class="line">&quot;1067.3788&quot;</span><br></pre></td></tr></table></figure>

<p><strong>georadius、georadiusbymember</strong></p>
<p><code>georadius</code>以给定的经纬度为中心，返回键包含的位置元素当中，与中心的距离不超过给定最大距离的所有位置元素</p>
<p><code>georadiusbymember</code>和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素，但是georadiusbymember的中心点是由给定的位置元素决定的，而不是使用经度和纬度来决定中心点</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>withcoord：将位置元素的经度和纬度也一并返回</li>
<li>withdist：在返回位置元素的同时，将位置元素与中心之间的距离也一并返回</li>
<li>withhash：以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
<li>count：限定返回的记录数</li>
<li>asc：查找结果根据距离从近到远排序</li>
<li>desc：从远到近排序</li>
<li>store key：将返回结果的地理位置信息保存到指定键</li>
<li>storedist key：将返回结果距离中心节点的距离保存到指定键</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> GEORADIUS Sicily 15 37 200 km WITHDIST</span><br><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) &quot;190.4424&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) &quot;56.4413&quot;</span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD</span><br><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) 1) &quot;13.361389338970184&quot;</span><br><span class="line">      2) &quot;38.115556395496299&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) 1) &quot;15.087267458438873&quot;</span><br><span class="line">      2) &quot;37.50266842333162&quot;</span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) &quot;190.4424&quot;</span><br><span class="line">   3) 1) &quot;13.361389338970184&quot;</span><br><span class="line">      2) &quot;38.115556395496299&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) &quot;56.4413&quot;</span><br><span class="line">   3) 1) &quot;15.087267458438873&quot;</span><br><span class="line">      2) &quot;37.50266842333162&quot;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">redis&gt; GEOADD Sicily 13.583333 37.316667 &quot;Agrigento&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km</span><br><span class="line">1) &quot;Agrigento&quot;</span><br><span class="line">2) &quot;Palermo&quot;</span><br></pre></td></tr></table></figure>

<p><strong>geohash</strong></p>
<p>Redis GEO 使用 geohash 来保存地理位置的坐标。</p>
<p>geohash 用于获取一个或多个位置元素的 geohash 值。</p>
<p>geohash 语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEOHASH key member [member ...]</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line">1) &quot;sqc8b49rny0&quot;</span><br><span class="line">2) &quot;sqdtr74hyu0&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-HyperLogLog"><a href="#3-9-HyperLogLog" class="headerlink" title="3.9.HyperLogLog"></a>3.9.HyperLogLog</h3><p>Redis HyperLogLog 是用来做<code>基数统计</code>的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是<code>固定</code> 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<blockquote>
<p>HyperLogLog常用命令</p>
</blockquote>
<ul>
<li><p>pfadd key element…:添加指定元素到HyperLogLog</p>
<ul>
<li>pfcount key…:返回给定HyperLogLog的基数估算值</li>
</ul>
</li>
<li><p>pfmerge destkey sourcekey…：将多个HyperLogLog合并为一个HtperLogLog</p>
</li>
</ul>
<blockquote>
<p>使用经验</p>
</blockquote>
<ul>
<li>是否能容忍错误？(错误率：0.81%)</li>
<li>是否需要单条数据</li>
</ul>
<h3 id="3-10-Bitmaps"><a href="#3-10-Bitmaps" class="headerlink" title="3.10.Bitmaps"></a>3.10.Bitmaps</h3><p>Redis中的位存储，可以用来统计用户信息，如：活跃状态，打卡等</p>
<p>bitmaps位图，数据结构。都是操作二进制位来进行记录，就只有0和1两个状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7j51d.png" alt="image-20230203154648868"></p>
<p>特别节省内存</p>
<ul>
<li>setbit key offset value：给位图指定索引设置值，返回原先这个位置的值</li>
<li>getbit key offset：获取给定偏移量的值</li>
<li>bitcount key [start end]：获取位图指定范围(start-end，单位为字节，默认为全部)位值为1的个数</li>
<li>bitop op destkey key…：做多个Bitmap的and(交集)、or(并集)、not(非)、xor(异或)操作并将结果保存在destkey中</li>
<li>bitpos key [0-1] [start end]：计算位图指定范围第一个出现0或1的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 记录周一到周天的打卡</span><br><span class="line">setbit sign 1 0 # 设置星期一未打卡</span><br><span class="line">getbit sign 1   # 查看星期一是否打卡</span><br><span class="line">bitcount sign 0 1 # 统计sign中[0-1]的个数</span><br><span class="line">bitop and hello op oq # 做交集放在hello中</span><br></pre></td></tr></table></figure>

<h3 id="3-11-Stream"><a href="#3-11-Stream" class="headerlink" title="3.11.Stream"></a>3.11.Stream</h3><p>Redis Stream是Redis 5.0版本新增加的数据结构</p>
<p>Redis Stream主要用于消息队列(MQ,Message Queue)，Redis本身是有一个发布订阅来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开，Redis宕机等，消息就会被丢弃</p>
<p>简单来说发布订阅可以分发消息，但是无法记录历史消息</p>
<p>而Redis Stream提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失</p>
<p>Redis Stream的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/ywyn6y-0.png" alt="img"></p>
<p>每个Stream都有唯一的名称，它就是Redis的key，在我们首次使用xadd指令追加消息时自动创建</p>
<ul>
<li>Consumer Group：消费组，使用XGROUP CREATE命令创建，一个消费组有多个消费者(Consumer)</li>
<li>last_delivered_id：游标，每个消费组会有个游标last_delivered_id，任意一个消费组读取了消息都会使游标last_delivered_id往前移动</li>
<li>pending_ids：消费组(Consumer)的状态变量，作用是维护消费组未确认的id。pending_ids记录了当前已经被客户端读取的消息，但是还没有ack(Acknowledge character：确认字符)</li>
</ul>
<p><strong>消息队列相关命令</strong>：</p>
<ul>
<li>XADD：添加消息到末尾</li>
<li>XTRIM：对流进行修剪，限制长度</li>
<li>XDEL：删除消息</li>
<li>XLEN：获取流包含的元素数量，即消息长度</li>
<li>XRANGE：获取消息列表，会自动过滤已经删除的消息</li>
<li>XREVRANGE：反向获取消息列表，ID从大到小</li>
<li>XREAD：以阻塞或非阻塞方式获取消息列表</li>
</ul>
<p><strong>消费者组相关命令</strong>：</p>
<ul>
<li>XGROUP CREATE:创建消费组组</li>
<li>XREADGROUP GROUP：读取消费者组中的消息</li>
<li>XACK：将消息标记为已处理</li>
<li>XGROUP SETID：为消费者组设置新的最后传送消息ID</li>
<li>XGROUP DELCONSUMER：删除消费者</li>
<li>XGROUP DESTROY：删除消费者组</li>
<li>XPENDING：显示待处理消息的相关信息</li>
<li>XCLAIM：转移消息的归属权</li>
<li>XINFO：查看流和消费者组的相关信息</li>
<li>XINFO GROUPS：打印消费者组的信息</li>
<li>XINFO STREAM：打印流信息</li>
</ul>
<p><strong>XADD</strong></p>
<p>使用XADD向队列添加消息，如果指定的队列不存在，则创建一个队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XADD key ID field value [field value...]</span><br></pre></td></tr></table></figure>

<ul>
<li>key：队列名称</li>
<li>ID：消息id，可以使用*表示由redis生成，可以自定义，但是要保证递增性</li>
<li>field value：记录</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; XADD mystream * name Sara surname OConnor</span><br><span class="line">&quot;1601372323627-0&quot;</span><br><span class="line">redis&gt; XADD mystream * field1 value1 field2 value2 field3 value3</span><br><span class="line">&quot;1601372323627-1&quot;</span><br><span class="line">redis&gt; XLEN mystream</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1601372323627-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Sara&quot;</span><br><span class="line">      3) &quot;surname&quot;</span><br><span class="line">      4) &quot;OConnor&quot;</span><br><span class="line">2) 1) &quot;1601372323627-1&quot;</span><br><span class="line">   2) 1) &quot;field1&quot;</span><br><span class="line">      2) &quot;value1&quot;</span><br><span class="line">      3) &quot;field2&quot;</span><br><span class="line">      4) &quot;value2&quot;</span><br><span class="line">      5) &quot;field3&quot;</span><br><span class="line">      6) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>XTRIM</strong>：</p>
<p>使用XTRIM对流进行修剪，限制长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XTRIM key MAXLEN [~] count</span><br></pre></td></tr></table></figure>

<ul>
<li>key：消息队列</li>
<li>MAXLEN：长度</li>
<li>count：数量</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD mystream * field1 A field2 B field3 C field4 D</span><br><span class="line">&quot;1601372434568-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream MAXLEN 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1601372434568-0&quot;</span><br><span class="line">   2) 1) &quot;field1&quot;</span><br><span class="line">      2) &quot;A&quot;</span><br><span class="line">      3) &quot;field2&quot;</span><br><span class="line">      4) &quot;B&quot;</span><br><span class="line">      5) &quot;field3&quot;</span><br><span class="line">      6) &quot;C&quot;</span><br><span class="line">      7) &quot;field4&quot;</span><br><span class="line">      8) &quot;D&quot;</span><br></pre></td></tr></table></figure>

<p><strong>XDEL</strong>：</p>
<p>使用XDEL删除消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XDEL key ID [ID..]</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; XADD mystream * a 1</span><br><span class="line">1538561698944-0</span><br><span class="line">&gt; XADD mystream * b 2</span><br><span class="line">1538561700640-0</span><br><span class="line">&gt; XADD mystream * c 3</span><br><span class="line">1538561701744-0</span><br><span class="line">&gt; XDEL mystream 1538561700640-0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) 1538561698944-0</span><br><span class="line">   2) 1) &quot;a&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br><span class="line">2) 1) 1538561701744-0</span><br><span class="line">   2) 1) &quot;c&quot;</span><br><span class="line">      2) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>XLEN</strong>：</p>
<p>使用XLEN获取流包含的元素，即消息长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XLEN key</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; XADD mystream * item 1</span><br><span class="line">&quot;1601372563177-0&quot;</span><br><span class="line">redis&gt; XADD mystream * item 2</span><br><span class="line">&quot;1601372563178-0&quot;</span><br><span class="line">redis&gt; XADD mystream * item 3</span><br><span class="line">&quot;1601372563178-1&quot;</span><br><span class="line">redis&gt; XLEN mystream</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p><strong>XRANGE</strong>：</p>
<p>使用XRANGE获取消息列表，会自动过滤已经删除的消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XRANGE key start end [COUNT count]</span><br></pre></td></tr></table></figure>

<ul>
<li>key:队列名</li>
<li>start：开始值，<code>-</code>表示最小值</li>
<li>end：结束值，<code>+</code>表示最大值</li>
<li>count：数量</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; XADD writers * name Virginia surname Woolf</span><br><span class="line">&quot;1601372577811-0&quot;</span><br><span class="line">redis&gt; XADD writers * name Jane surname Austen</span><br><span class="line">&quot;1601372577811-1&quot;</span><br><span class="line">redis&gt; XADD writers * name Toni surname Morrison</span><br><span class="line">&quot;1601372577811-2&quot;</span><br><span class="line">redis&gt; XADD writers * name Agatha surname Christie</span><br><span class="line">&quot;1601372577812-0&quot;</span><br><span class="line">redis&gt; XADD writers * name Ngozi surname Adichie</span><br><span class="line">&quot;1601372577812-1&quot;</span><br><span class="line">redis&gt; XLEN writers</span><br><span class="line">(integer) 5</span><br><span class="line">redis&gt; XRANGE writers - + COUNT 2</span><br><span class="line">1) 1) &quot;1601372577811-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Virginia&quot;</span><br><span class="line">      3) &quot;surname&quot;</span><br><span class="line">      4) &quot;Woolf&quot;</span><br><span class="line">2) 1) &quot;1601372577811-1&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Jane&quot;</span><br><span class="line">      3) &quot;surname&quot;</span><br><span class="line">      4) &quot;Austen&quot;</span><br></pre></td></tr></table></figure>

<p><strong>XREAD</strong></p>
<p>使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>count</strong> ：数量</li>
<li><strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式</li>
<li><strong>key</strong> ：队列名</li>
<li><strong>id</strong> ：消息 ID</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从 Stream 头部读取两条消息</span><br><span class="line">&gt; XREAD COUNT 2 STREAMS mystream writers 0-0 0-0</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) 1526984818136-0</span><br><span class="line">         2) 1) &quot;duration&quot;</span><br><span class="line">            2) &quot;1532&quot;</span><br><span class="line">            3) &quot;event-id&quot;</span><br><span class="line">            4) &quot;5&quot;</span><br><span class="line">            5) &quot;user-id&quot;</span><br><span class="line">            6) &quot;7782813&quot;</span><br><span class="line">      2) 1) 1526999352406-0</span><br><span class="line">         2) 1) &quot;duration&quot;</span><br><span class="line">            2) &quot;812&quot;</span><br><span class="line">            3) &quot;event-id&quot;</span><br><span class="line">            4) &quot;9&quot;</span><br><span class="line">            5) &quot;user-id&quot;</span><br><span class="line">            6) &quot;388234&quot;</span><br><span class="line">2) 1) &quot;writers&quot;</span><br><span class="line">   2) 1) 1) 1526985676425-0</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Virginia&quot;</span><br><span class="line">            3) &quot;surname&quot;</span><br><span class="line">            4) &quot;Woolf&quot;</span><br><span class="line">      2) 1) 1526985685298-0</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jane&quot;</span><br><span class="line">            3) &quot;surname&quot;</span><br><span class="line">            4) &quot;Austen&quot;</span><br></pre></td></tr></table></figure>

<p><strong>XGROUP CREATE</strong></p>
<p>使用 XGROUP CREATE 创建消费者组，语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key</strong> ：队列名称，如果不存在就创建</li>
<li><strong>groupname</strong> ：组名。</li>
<li><strong>$</strong> ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</li>
</ul>
<p><strong>实例</strong>：</p>
<p>从头开始消费:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE mystream consumer-group-name 0-0  </span><br></pre></td></tr></table></figure>

<p>从尾部开始消费:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE mystream consumer-group-name $</span><br></pre></td></tr></table></figure>

<h3 id="3-12-XREADGROUP-GROUP"><a href="#3-12-XREADGROUP-GROUP" class="headerlink" title="3.12.XREADGROUP GROUP"></a>3.12.XREADGROUP GROUP</h3><p>使用 XREADGROUP GROUP 读取消费组中的消息，语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>group</strong> ：消费组名</li>
<li><strong>consumer</strong> ：消费者名。</li>
<li><strong>count</strong> ： 读取数量。</li>
<li><strong>milliseconds</strong> ： 阻塞毫秒数。</li>
<li><strong>key</strong> ： 队列名。</li>
<li><strong>ID</strong> ： 消息 ID。</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream &gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-慢查询"><a href="#4-慢查询" class="headerlink" title="4.慢查询"></a>4.慢查询</h2><ul>
<li><p>生命周期</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7j0o5.png" alt="image-20230203152050440"></p>
<ul>
<li>慢查询发生在第三阶段</li>
<li>客户端超时不一定慢查询，但慢查询时客户端超时的一个可能因素</li>
</ul>
</li>
</ul>
<blockquote>
<p>两个配置</p>
</blockquote>
<ul>
<li><p>slowlog-max-len</p>
<ul>
<li>先进先出队列</li>
<li>固定长度</li>
<li>保存在内存内</li>
</ul>
</li>
<li><p>slowlog-log-slower-than</p>
<ul>
<li>慢查询阈值(微秒)</li>
<li>slowlog-log-slower-than&#x3D;0，记录所有命令</li>
<li>slowlog-log-slower-than&lt;0，不记录所有命令</li>
</ul>
</li>
<li><p>配置方法</p>
<ul>
<li><p>默认值	</p>
<ul>
<li>config get slowlog-max-len&#x3D;128</li>
<li>config get slowlog-log-slower-than&#x3D;10000</li>
</ul>
</li>
<li><p>修改配置文件重启</p>
</li>
<li><p>动态配置</p>
<ul>
<li>config set slowlog-max-len 1000</li>
<li>config set slowlog-log-slower-than 1000</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>慢查询命令</p>
</blockquote>
<ul>
<li>slowlog get [n]:获取慢查询队列</li>
<li>slowlog len:获取慢查询队列长度  </li>
<li>slowlog reset:清空慢查询队列</li>
</ul>
<blockquote>
<p>运维经验</p>
</blockquote>
<ul>
<li>slowlog-max-len不要过小，通常设置1000左右</li>
<li>slowlog-log-slower-than不要设置过大，默认10ms，通常设置1ms</li>
<li>理解生命周期</li>
<li>定期持久化慢查询</li>
</ul>
<h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h2><p>Redis事务：一组命令的集合，Redis单挑命令保存原子性，但是事务不保证原子性</p>
<ul>
<li>批量操作在发送exec命令前被放入队列缓存</li>
<li>收到exec命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
<li>一次性，顺序性，排他性</li>
</ul>
<p><strong>事务流程</strong>：</p>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<h3 id="5-1-事务常用命令"><a href="#5-1-事务常用命令" class="headerlink" title="5.1.事务常用命令"></a>5.1.事务常用命令</h3><ul>
<li>discard：取消事务，放弃执行事务块内的所有命令</li>
<li>exec：执行所有事务块内的命令</li>
<li>multi：标记一个事务块的开始</li>
<li>unwatch：取消watch命令对所有key的监视</li>
<li>watch key…：监视一个或多个key，如果事务执行之前这个key被其他命令所改动，那么事务被打断</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a 100                                                                                 &lt;transaction&gt;</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set b 1000                                                                                &lt;transaction&gt;</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get a                                                                                     &lt;transaction&gt;</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get b                                                                                     &lt;transaction&gt;</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; del a b                                                                                   &lt;transaction&gt;</span><br><span class="line">DEL will delete keys, it may cause high latency when the value is big.</span><br><span class="line">Do you want to proceed? (y/n): y</span><br><span class="line">Your Call!!</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec                                                                                      &lt;transaction&gt;</span><br><span class="line">1) &quot;OK&quot;</span><br><span class="line">2) &quot;OK&quot;</span><br><span class="line">3) &quot;100&quot;</span><br><span class="line">4) &quot;1000&quot;</span><br><span class="line">5) &quot;2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-乐观锁"><a href="#5-2-乐观锁" class="headerlink" title="5.2.乐观锁"></a>5.2.乐观锁</h3><p><strong>悲观锁</strong>：很悲观，认为什么时候都会出问题，无论做什么都会加锁</p>
<p><strong>乐观锁</strong>：很乐观，认为什么时候都不会除问题，所以不会上锁</p>
<ul>
<li>测试多线程修改值，在事务中用<code>watch</code>来实现乐观锁</li>
</ul>
<h2 id="6-Redis持久化"><a href="#6-Redis持久化" class="headerlink" title="6.Redis持久化"></a>6.Redis持久化</h2><p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能</p>
<p>redis所有数据保存在内存中，对数据的更新将异步的保存在磁盘上</p>
<h3 id="6-1-RDB-Redis-DataBase"><a href="#6-1-RDB-Redis-DataBase" class="headerlink" title="6.1.RDB(Redis DataBase)"></a>6.1.RDB(Redis DataBase)</h3><blockquote>
<p>什么是RDB？</p>
</blockquote>
<p>在主从复制中，rdb就是备用在从机上</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yyz4iw-0.png" alt="image-20230307211457393"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的回复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效，RDB的缺点是最后一次持久化后的数据可能丢失。默认就是RDB，一般情况下不需要修改配置</p>
<p>&#x3D;&#x3D;rdb保存的文件是dump.rdb&#x3D;&#x3D;</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li><p>配置中设置自动持久化(执行bgsave)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1 -&gt; 900秒内至少有一次修改则触发保存操作</span><br><span class="line">save 300 10	-&gt; 300秒内至少有10次修改则触发保存操作</span><br><span class="line">save 60 10000 -&gt; 60秒内至少有1万次修改则触发保存操作</span><br><span class="line">dbfilename dump.rdb -&gt; 生成的rdm文件名</span><br><span class="line"><span class="built_in">dir</span> ./ -&gt; 生成文件的存放路径</span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span> -&gt; 当写入发送错误是否停止</span><br><span class="line">rdbcompression <span class="built_in">yes</span> -&gt; rdb文件是否使用压缩格式</span><br><span class="line">rdbchecksum <span class="built_in">yes</span> -&gt; 是否对rdb文件进行校验</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jdsu.png" alt="image-20230204174508342"></p>
</li>
<li><p>全量复制</p>
</li>
<li><p>执行flushall命令，也会触发rdb规则，但是得到的是一个空文件</p>
</li>
<li><p>退出redis进程，也会触发(shutdown,debug reload)</p>
</li>
</ol>
<blockquote>
<p>持久化命令</p>
</blockquote>
<ul>
<li><p>执行save(O(n))的情况下，会自动生成rdb文件，此命令是同步命令，会堵塞其他命令,如果有老的文件则会被新文件替换。bgsave是异步的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7j00j.png"></p>
</li>
</ul>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li>只需要将rdb文件放在redis rdb存放目录，redis启动的时候回自动检测dump.rdb恢复其中的数据</li>
<li>查看启动目录：config get dir</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据完整性要求不高</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要一定的时间间隔进程操作！如果redis以外宕机了，这个最后一次修改数据就没有的了</li>
<li>fork进程的时候，会占用一定的内容空间</li>
</ol>
<blockquote>
<p>总结</p>
</blockquote>
<ol>
<li>RDB时Redis内存到硬盘的快照，用于持久化</li>
<li>save通常会阻塞Redis</li>
<li>bgsave不会阻塞redis，但是会fork新进程</li>
<li>save自动配置满足任一就会被执行</li>
<li>有些触发机制不容忽视</li>
</ol>
<h3 id="6-2-AOF-Append-Only-File"><a href="#6-2-AOF-Append-Only-File" class="headerlink" title="6.2.AOF(Append Only File)"></a>6.2.AOF(Append Only File)</h3><p>将我们的所有命令都记录下来，history，恢复的时候就再重复执行一遍</p>
<blockquote>
<p>AOF是什么</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/yztdgq-0.png" alt="image-20230307211557900"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录)，只许追加文件但不也可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>&#x3D;&#x3D;AOF保存的是appendonly.aof文件&#x3D;&#x3D;</p>
<p>默认是不开启的。要开启的话将配置文件中”appendonly no”改成yes</p>
<p>如果aof文件有错位，这时候redis是启动不起来的，我们需要修复这个aof文件</p>
<p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br><span class="line"># 修复appendonly.aof文件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AOF三种策略</p>
</blockquote>
<ol>
<li><p>always</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jau2.png" alt="image-20230208160358315"></p>
</li>
<li><p>everysec(<strong>默认</strong>)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jbn8.png" alt="image-20230208160412133"></p>
</li>
<li><p>no</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7j8ca.png" alt="image-20230208160440687"></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7j87d.png" alt="image-20230208160500494"></p>
<blockquote>
<p>AOF重写</p>
</blockquote>
<p>对过期的、没有用的、重复的、可优化的数据进行化简。<strong>可以减少硬盘占用量，加速恢复速度</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7j7kd.png" alt="image-20230208160933867"></p>
<blockquote>
<p>AOF重写实现的两种方式</p>
</blockquote>
<ul>
<li><p>bgrewriteaof命令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jh2j.png" alt="image-20230208161218164"></p>
</li>
<li><p>AOF重写配置</p>
<table>
<thead>
<tr>
<th>配置名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>auto-aof-rewrite-min-size</td>
<td>AOF文件重写需要的尺寸</td>
</tr>
<tr>
<td>auto-aof-rewrite-percentage</td>
<td>AOF文件增长率</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>统计名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>aof_current_size</td>
<td>AOF当前尺寸(字节)</td>
</tr>
<tr>
<td>zof_base_size</td>
<td>AOF上次启动和重写的尺寸(字节)</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jgxi.png" alt="image-20230208161708671"></p>
</li>
</ul>
<blockquote>
<p>AOF相关配置</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jhfy.png" alt="image-20230208162142618"></p>
<p><strong>no-appendfsync-on-rewrite yes：表示在日志重写时，不进行命令追加操作，而只是将命令放在重写缓冲区里，避免与命令的追加造成磁盘 IO 上的冲突</strong></p>
<p><strong>优点</strong>：</p>
<ol>
<li>每一次修改都同步</li>
<li>默认每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</li>
<li>aof运行效率比rdb慢，</li>
</ol>
<h3 id="6-3-总结"><a href="#6-3-总结" class="headerlink" title="6.3.总结"></a>6.3.总结</h3><ol>
<li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候回重新执行这些命令来恢复原始数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</li>
<li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li>
<li>同时开启两种持久化方式<ol>
<li>在这种情况下，当Redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据要完整</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，但是RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会又AOF可能潜在的Bug，留着作为一个万一的手段</li>
</ol>
</li>
<li>性能建议<ol>
<li>因为RDB文件只用作后备用途，建议只在slave上持久化RDB文件，而且只要15分钟备份一次就够了，值保留save 900 1 这条规则</li>
<li>如果Enable AOF，好处是在最恶劣情况下也只会地址不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价以是带来了持续的IO，而是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewirite的频率，AOF重写的基础大小默认值64M太小，可以设到5g以上，默认超过原大小100%大小重写可以改到适当的数值</li>
<li>如果不Enable AOF，仅靠Master-Slave-Repllcation实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master&#x2F;Slave中的RDB文件，载入较新的那个，微博就是这种架构</li>
</ol>
</li>
</ol>
<h3 id="6-4-Redis持久化的取舍和选择"><a href="#6-4-Redis持久化的取舍和选择" class="headerlink" title="6.4.Redis持久化的取舍和选择"></a>6.4.Redis持久化的取舍和选择</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jfc4.png" alt="image-20230208163148641"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jkmf.png" alt="image-20230208163444316"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jk4f.png" alt="image-20230208163618701"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jid8.png" alt="image-20230208163716218"></p>
<h3 id="6-5-Redis持久化运维常见问题"><a href="#6-5-Redis持久化运维常见问题" class="headerlink" title="6.5.Redis持久化运维常见问题"></a>6.5.Redis持久化运维常见问题</h3><blockquote>
<p>fork操作</p>
</blockquote>
<ul>
<li>同步操作</li>
<li>与内存量息息相关：内存越大，耗时越长(与机器类型有关)</li>
<li>info：latest_fork_usec</li>
</ul>
<blockquote>
<p>改善fork</p>
</blockquote>
<ul>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术</li>
<li>控制Redis实例最大可用内存：maxmemory</li>
<li>合理配置Linux内存分配策略：vm.overcommit_memory&#x3D;1</li>
<li>降低fork频率：例如放宽AOF重写自动触发机制时机，不必要的全量复制</li>
</ul>
<blockquote>
<p>子进程开销和优化</p>
</blockquote>
<ol>
<li>CPU<ul>
<li>开销：RDB和AOF文件生成，属于CPU密集型</li>
<li>优化：不做CPU绑定，不和CPU密集型部署</li>
</ul>
</li>
<li>内存<ul>
<li>开销：fork内存开销，copy-on-write</li>
<li>优化：echo never&gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</li>
</ul>
</li>
<li>硬盘<ul>
<li>开销：AOF和RDB文件写入，可以结合iostat，iotop分析</li>
<li>优化：<ul>
<li>不要和高硬盘负载服务部署在一起：存储服务、消息队列等</li>
<li>no-appendfsync-on-rewrite &#x3D; yes</li>
<li>根据写入量决定磁盘类型：例如ssd</li>
<li>单机多实例持久化文件目录可以考虑分盘</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>AOF追加阻塞</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jqd0.png" alt="image-20230208170332753"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7jn8t.png" alt="image-20230208170534344"></p>
<h2 id="7-发布订阅"><a href="#7-发布订阅" class="headerlink" title="7.发布订阅"></a>7.发布订阅</h2><p>Redis发布订阅(push&#x2F;sub)是一种<code>消息通信模式</code>：发送者(pub)发送消息，订阅者(sub)订阅消息。Redis客户端可以订阅任意数量的频道</p>
<p>下图展示了频道channel1，以及订阅这个频道的三个客户端–client2,、client5、client1之间的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z03n3x-0.png" alt="img"></p>
<p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会发送给订阅它的三个客户端</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z0f7rb-0.png" alt="img"></p>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 我们打开两个redis-cli客户端</span><br><span class="line"># 在第一个客户端订阅频道，为订阅端</span><br><span class="line">subscribe runoobChat</span><br><span class="line"># 结果：subscribe from runoobChat: 1</span><br><span class="line"># 在第二个客户端发送消息，为发送端</span><br><span class="line">publish runoobChat &#x27;redis publish test&#x27;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish runoobChat &#x27;learn redis by runoob.com&#x27;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 在订阅端会显示</span><br><span class="line">message   from runoobChat: redis publish test</span><br><span class="line">message   from runoobChat: learn redis by runoob.com</span><br></pre></td></tr></table></figure>

<h3 id="7-1-订阅常用命令"><a href="#7-1-订阅常用命令" class="headerlink" title="7.1.订阅常用命令"></a>7.1.订阅常用命令</h3><ul>
<li>PSUBSCRIBE pattern…:订阅一个或多个符合给定模式的频道</li>
<li>PUBSUB subcommand [argument…]:查看订阅与发布系统状态</li>
<li>PUBLISH channel message：将消息发送到指定的频道，返回订阅者数量</li>
<li>PUNSUBSCRIBE [pattern…]：退订所有给定模式的频道</li>
<li>SUBSCRIBE channel…：订阅给定的一个或多个频道的信息</li>
<li>UNSUBSCRIBE [channel…]：退订给定的频道</li>
</ul>
<h3 id="7-2-原理"><a href="#7-2-原理" class="headerlink" title="7.2.原理"></a>7.2.原理</h3><p>Redis是使用c实现的，通过分析Redis源码里的pubsub.c文件，可以了解发布与订阅机制的底层实现</p>
<p>Redis通过PUBLISH、SUBSCRIBE等命令实现发布和订阅功能</p>
<p>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个channel，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中</p>
<p>通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者</p>
<p>PUB&#x2F;SUB从字面上理解就是发布(publish)与订阅(subscribe),在redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到响应的消息。这一功能最明显的语法就是用作实时消息系统</p>
<h2 id="8-Redis连接命令"><a href="#8-Redis连接命令" class="headerlink" title="8.Redis连接命令"></a>8.Redis连接命令</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p>
<ul>
<li>AUTH password：验证密码是否正确</li>
<li>ECHO message：打印字符串</li>
<li>PING：查看服务是否运行，正常会返回PONG</li>
<li>QUIT：关闭当前连接</li>
<li>SELECT index：切换到指定的数据库</li>
</ul>
<h2 id="9-Redis服务器"><a href="#9-Redis服务器" class="headerlink" title="9.Redis服务器"></a>9.Redis服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z13ndg-0.png" alt="image-20230307211813860"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看是否设置了密码</span><br><span class="line"> config get required</span><br><span class="line"></span><br><span class="line"># 设置密码</span><br><span class="line"> config set required &#x27;runoob&#x27;</span><br><span class="line"></span><br><span class="line"># 验证密码</span><br><span class="line">AUTH runoob</span><br></pre></td></tr></table></figure>



<h2 id="10-Redis客户端连接"><a href="#10-Redis客户端连接" class="headerlink" title="10.Redis客户端连接"></a>10.Redis客户端连接</h2><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p>
<ul>
<li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li>
<li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li>
<li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li>
</ul>
<p><strong>最大连接数</strong></p>
<p>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p>
<p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config get maxclients</span><br><span class="line"></span><br><span class="line">1) &quot;maxclients&quot;</span><br><span class="line">2) &quot;10000&quot;</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>以下实例我们在服务启动时设置最大连接数为 100000：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --maxclients 100000</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z1n0tv-0.png" alt="image-20230307211904757"></p>
<h2 id="11-Redis-性能测试"><a href="#11-Redis-性能测试" class="headerlink" title="11.Redis 性能测试"></a>11.Redis 性能测试</h2><p>Redis性能测试使通过同时执行多个命令实现的。</p>
<p>redis性能测试的基本命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该命令是在redis目录下执行</p>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-benchmark -n 100 -q</span><br><span class="line">PING_INLINE: 25000.00 requests per second</span><br><span class="line">PING_BULK: 20000.00 requests per second</span><br><span class="line">SET: 20000.00 requests per second</span><br><span class="line">GET: 25000.00 requests per second</span><br><span class="line">INCR: 25000.00 requests per second</span><br><span class="line">LPUSH: 561.80 requests per second</span><br><span class="line">RPUSH: 20000.00 requests per second</span><br><span class="line">LPOP: 20000.00 requests per second</span><br><span class="line">RPOP: 25000.00 requests per second</span><br><span class="line">SADD: 25000.00 requests per second</span><br><span class="line">SPOP: 20000.00 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 25000.00 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 12500.00 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 10000.00 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 9090.91 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 12500.00 requests per second</span><br><span class="line">MSET (10 keys): 20000.00 requests per second</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z1ttz0-0.png" alt="image-20230307211936295"></p>
<h2 id="12-Redis管道技术-pipeline"><a href="#12-Redis管道技术-pipeline" class="headerlink" title="12.Redis管道技术(pipeline)"></a>12.Redis管道技术(pipeline)</h2><p>Redis是一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应</li>
<li>服务端处理命令，并将结果返回给客户端</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>N个命令操作</th>
<th>1次pipeline(n个命令)</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>n次网络+n次命令</td>
<td>1次网络+n次命令</td>
</tr>
<tr>
<td>数据量</td>
<td>1一条命令</td>
<td>n条命令</td>
</tr>
</tbody></table>
<p><strong>Redis的命令时间是微秒级别。pipeline每次条数要控制(网络)</strong></p>
<p>Redis管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应，管道技术显著提高了redis服务的性能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看 redis 管道，只需要启动 redis 实例并输入以下命令：</span><br><span class="line"></span><br><span class="line">$(echo -en &quot;PING\r\n SET runoobkey redis\r\nGET runoobkey\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379</span><br><span class="line"></span><br><span class="line">+PONG</span><br><span class="line">+OK</span><br><span class="line">redis</span><br><span class="line">:1</span><br><span class="line">:2</span><br><span class="line">:3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用建议</p>
</blockquote>
<ol>
<li>注意每次pipeline携带数据量</li>
<li>pipeline每次只能作用在一个Redis节点上</li>
<li>M操作与pipeline区别</li>
</ol>
<h2 id="13-Redis主从复制"><a href="#13-Redis主从复制" class="headerlink" title="13.Redis主从复制"></a>13.Redis主从复制</h2><p><strong>概念</strong></p>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器，前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的赋值是<strong>单向</strong>的，只能由主节点到从节点。<strong>Master以写为主，Slave以读为主</strong></p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点或没有从节点，但一个从节点只能有一个主节点。</p>
<p>主从复制的作用包括：</p>
<ol>
<li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li>
<li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点)，分担服务器负载；尤其在写少读多的场景下，通过多个从节点分担负载，可以大大提高Redis服务器的并发量</li>
<li><strong>高可用基石</strong>：除了上述作用外，主从复制还是哨兵和机群能实施的基础，一次说主从复制是Redis高可用性的基础</li>
</ol>
<p>一般来说，要将Redis运用于工程项目中，只使用一台redis是不可能的(宕机，一主二从)，因为：</p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256g，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20g</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z2txwz-0.png" alt="image-20230307212105288"></p>
<h3 id="13-1-基础"><a href="#13-1-基础" class="headerlink" title="13.1.基础"></a>13.1.基础</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境配置</span><br><span class="line"></span><br><span class="line">info REPLICATION # 查看当期库的信息</span><br><span class="line"># Replication</span><br><span class="line">role:master  # 角色</span><br><span class="line">connected_slaves:0  # 没有从机</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">在一台机器模拟主从需要开启三个服务，则需要三个配置文件</span><br><span class="line">且相对于的服务的配置文件要进行相应的修改</span><br><span class="line">port 6379  # 对应的端口号要改</span><br><span class="line">daemonize yes # 后台服务要开启</span><br><span class="line">pidfile /var/run/redis-6379.pid # 后台进程文件修改</span><br><span class="line">logfile # 日志文件配置</span><br><span class="line">dbfilename dump.rdb  # 持久化文件修改</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 一主二从配置</span><br><span class="line"># 只配置从机，不用配置主机</span><br><span class="line"># 在从机中使用此命令指认主机</span><br><span class="line"># 也可以在配置文件中配置此命令设置主机</span><br><span class="line">slaveof ip port</span><br><span class="line"># slaveof no one 命令可以在从节点断开主节点连接</span><br><span class="line">slave-read-only #配置从节点只读</span><br></pre></td></tr></table></figure>



<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以写，从机只能读。主机中的所有信息和数据，都会被自动保存在从机。</p>
<p>当没有配置哨兵而主机挂了的时候，从机任然是从机，除非手动修改配置，只要一变成从机，立马就会从主机中拿到数据</p>
<blockquote>
<p>赋值原理</p>
</blockquote>
<p>Slave启动成功连接到master后会发送一个sync同步命令</p>
<p>master接到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次同步</p>
<p><code>全量复制</code>：而slave服务在接受到数据库文件数据后，将其存盘并加载到内存中</p>
<p><code>增量复制</code>：master继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次<strong>完全同步</strong>(全量复制)将被自动执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7sgq6.png" alt="image-20230209105308456"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7sp95.png" alt="image-20230209105757428"></p>
<blockquote>
<p>全量复制开销</p>
</blockquote>
<ol>
<li>bgsave时间</li>
<li>RDB文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB的时间</li>
<li>可能的AOF重写时间</li>
</ol>
<p>主从可以有多种模式</p>
<ol>
<li><strong>同步模式（Synchronous Replication）：</strong><ul>
<li>在同步模式下，主节点在写入数据后等待所有从节点确认接收到数据，然后再向客户端发送成功响应。这确保了数据在主从节点之间的一致性，但也可能导致一些性能开销，尤其是在从节点与主节点之间的网络延迟较大时。</li>
</ul>
</li>
<li><strong>异步模式（Asynchronous Replication）：</strong><ul>
<li>在异步模式下，主节点将写入的数据立即返回给客户端，而不等待从节点确认。从节点会在后台异步地复制主节点的数据。这种模式可以提高写入性能，但在某些情况下可能导致主从节点之间的数据稍有延迟。</li>
</ul>
</li>
<li><strong>半同步模式（Semi-Synchronous Replication）：</strong><ul>
<li>半同步模式是同步模式和异步模式的一种折中。主节点等待至少一个从节点确认接收到数据后才响应客户端。这种方式在一定程度上保持了一致性，并减少了一些异步模式的延迟。</li>
</ul>
</li>
<li><strong>无磁盘复制（Diskless Replication）：</strong><ul>
<li>在无磁盘复制模式下，从节点不会将复制的数据写入磁盘，而是直接保存在内存中。这可以提高从节点的复制性能，但在从节点重启时会导致数据丢失。</li>
</ul>
</li>
<li><strong>断点续传（Resumable Replication）：</strong><ul>
<li>Redis 6.0 引入了断点续传功能，允许从节点在复制时断开连接，然后在网络重新连接后继续从断点处进行复制，而不是重新开始。这可以提高复制的可靠性。</li>
</ul>
</li>
</ol>
<blockquote>
<p>运维中常见问题</p>
</blockquote>
<ol>
<li>读写分离<ul>
<li>复制数据延迟</li>
<li>从节点故障</li>
</ul>
</li>
<li>主从配置不一致<ul>
<li>例如maxmemory不一致：丢失数据</li>
<li>例如数据结构优化参数(hash-max-ziplist-entries)：内存不一致</li>
</ul>
</li>
<li>规避全量复制<ul>
<li>第一次全量复制不可避免：小主节点、低峰</li>
<li>节点运行ID不匹配<ul>
<li>主节点重启(运行ID变化)</li>
<li>故障转移，例如哨兵或集群</li>
</ul>
</li>
<li>复制积压缓冲区不足<ul>
<li>网络中断，部分复制无法满足</li>
<li>增大复制缓冲区配置rel_backlog_size，网络增强</li>
</ul>
</li>
</ul>
</li>
<li>规避复制风暴<ul>
<li>单节点复制风暴<ul>
<li>问题：主节点重启，多从节点复制</li>
<li>解决：更换复制拓扑</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7sq7z.png" alt="image-20230209111859757"></p>
<h3 id="13-2-Redis-Sentinel架构"><a href="#13-2-Redis-Sentinel架构" class="headerlink" title="13.2.Redis Sentinel架构"></a>13.2.Redis Sentinel架构</h3><p>自动选举老大的模式</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。所以Redis从2.8开始正式提供了Sentinel(哨兵)架构来解决这个问题</p>
<p>哨兵能够自动监控主机是否故障，如果故障了<strong>根据投票数自动将从库转换成主库</strong></p>
<blockquote>
<p>作用步骤</p>
</blockquote>
<ol>
<li>多个sentinel发现并确认master有问题 </li>
<li>选举除一个sentinel作为领导</li>
<li>选出一个slave作为master</li>
<li>通知其他salve成为新的master的slave</li>
<li>通知客户端主从变化</li>
<li>等待老的master复活成为新master的slave</li>
</ol>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z3fesy-0.png" alt="image-20230307212205477"></p>
<p>这里哨兵有两个作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z4u6o9-0.png" alt="image-20230307212441268"></p>
<p>假设服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为<code>主观下线</code>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票(投票算法)，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<code>客观下线</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7sw9a.png" alt="image-20230209164647933"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7sxxs.png" alt="image-20230209165046647"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7sx1p.png" alt="image-20230209165303808"></p>
<blockquote>
<p>三个定时任务</p>
</blockquote>
<ol>
<li><strong>每10s</strong>每个sentinel对master和slave执行info<ul>
<li>发现slave节点</li>
<li>确认主从关系</li>
</ul>
</li>
<li><strong>每2s</strong>每个sentinel通过master节点的channel交换信息(pub&#x2F;sub)<ul>
<li>通过__sentinel__:hello频道交互</li>
<li>交互对节点的“看法”和自身信息</li>
</ul>
</li>
<li><strong>每1s</strong>每个sentinel对其他sentinel和redis执行ping<ul>
<li>心跳检测，失败判定依据</li>
</ul>
</li>
</ol>
<p><strong>哨兵启动步骤</strong>：</p>
<ol>
<li><strong>哨兵环境配置</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在安装目录下新建sentinel.conf</span></span><br><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line"><span class="built_in">dir</span> /tmp</span><br><span class="line"><span class="comment"># 配置守护进程启动和日志</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">logfile “26379.<span class="built_in">log</span>”</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line"><span class="comment"># 这个数字越小，完成failover所需的时间就越长，</span></span><br><span class="line"><span class="comment"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line"> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>启动哨兵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel 配置文件路径</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点都有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>Redis不好在线扩容，集群容量一旦到达上限，在线扩容会十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
<blockquote>
<p>节点运维问题</p>
</blockquote>
<ol>
<li>节点下线<ol>
<li>机器下线：例如过保等情况</li>
<li>机器性能不足：例如CPU、内存、硬盘、网络等</li>
<li>节点自身故障：例如服务不稳定等</li>
<li>从节点：临时下线还是永久下线，例如是否做一些清理工作。但是要考虑读写分离情况</li>
<li>sentinel节点同上</li>
</ol>
</li>
<li>节点上线<ol>
<li>主节点：sentinel failover进行替换</li>
<li>从节点：slaveof即可，sentinel节点可以感知</li>
<li>sentinel节点：参考其他sentinel节点启动即可</li>
</ol>
</li>
</ol>
<h3 id="13-3-总结"><a href="#13-3-总结" class="headerlink" title="13.3.总结"></a>13.3.总结</h3><ul>
<li>Redis Sentinel是Redis的高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知</li>
<li>Redis Sentinel从2.8版本开始使用</li>
<li>尽可能在不同物理机上部署Redis Sentinel所有节点</li>
<li>Redis Sentinel中的节点个数应该大于等于三，且最好为奇数</li>
<li>Redis Sentinel中的数据节点与普通数据节点没有区别</li>
<li>客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心不是代理</li>
<li>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化</li>
</ul>
<h2 id="14-Redis-Cluster"><a href="#14-Redis-Cluster" class="headerlink" title="14.Redis Cluster"></a>14.Redis Cluster</h2><blockquote>
<p>为什么需要集群？</p>
</blockquote>
<ul>
<li>需要更高的并发量(OPS)</li>
<li>需要更多的数据量</li>
</ul>
<h3 id="14-1-数据分布"><a href="#14-1-数据分布" class="headerlink" title="14.1.数据分布"></a>14.1.数据分布</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t0mu.png" alt="image-20230212160511046"></p>
<blockquote>
<p>顺序分区和哈希分区</p>
</blockquote>
<ul>
<li><p>哈希分布</p>
<ol>
<li><p>节点取余分区</p>
<ul>
<li>当采用节点取模时，如果节点扩容了，会导致<strong>数据大规模迁移</strong>(80%)；所以采用节点取模时，扩容最好采用多倍扩容(增加原节点数的倍数),这能<strong>有效减低数据迁移</strong>(50%)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t8mc.png"></p>
</li>
<li><p>一致性哈希分区</p>
<ul>
<li>客户端分片：哈希+顺时针(优化取余)</li>
<li>当采用此方法时扩容，只会导致一个临近节点的数据迁移</li>
<li>翻倍伸缩：保证最小迁移数据和负载均衡</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t96y.png" alt="image-20230212161713203"></p>
</li>
<li><p>虚拟槽分区</p>
<ul>
<li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li>
<li>良好的哈希函数：例如CRC16</li>
<li>服务端管理节点、槽、数据：例如Redis Cluster</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t3pe.png" alt="image-20230212162636441"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t4zm.png" alt="image-20230212160649498"></p>
<h3 id="14-2-Redis-Cluster架构"><a href="#14-2-Redis-Cluster架构" class="headerlink" title="14.2.Redis Cluster架构"></a>14.2.Redis Cluster架构</h3><blockquote>
<p>单机架构</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t64s.png" alt="image-20230212162913813"></p>
<blockquote>
<p>分布式架构</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t5to.png" alt="image-20230212162956893"></p>
<ul>
<li><p>节点</p>
<ul>
<li>启动集群模式：cluster-enabled：yes</li>
</ul>
</li>
<li><p>meet</p>
<ul>
<li>所有节点共享消息</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7t6ec.png" alt="image-20230212163356316"></p>
</li>
<li><p>指派槽</p>
<ul>
<li>客户端只需计算key</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tb2m.png" alt="image-20230212163444142"></p>
</li>
</ul>
<blockquote>
<p>Redis Cluster特性</p>
</blockquote>
<ul>
<li>复制</li>
<li>高可用</li>
<li>分片</li>
</ul>
<h3 id="14-3-Redis-Cluster安装"><a href="#14-3-Redis-Cluster安装" class="headerlink" title="14.3.Redis Cluster安装"></a>14.3.Redis Cluster安装</h3><blockquote>
<p>原生命令安装</p>
</blockquote>
<ol>
<li><p>配置开启节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ta2w.png" alt="image-20230212163946034"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster-enabled <span class="built_in">yes</span>  <span class="comment">#  开启集群模式</span></span><br><span class="line">cluster-node-timeout 15000   <span class="comment"># 超时时间</span></span><br><span class="line">cluster-config-file “nodes.conf”  <span class="comment"># 集群配置文件</span></span><br><span class="line">cluster-require-full-coverage <span class="built_in">yes</span> <span class="comment"># 是否全部节点都提供服务才认为集群正常工作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>meet</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tcxm.png" alt="image-20230212164201570"></p>
</li>
<li><p>指派槽</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7td5u.png" alt="image-20230212165058286"></p>
</li>
<li><p>主从</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tbh6.png" alt="image-20230212165251382"></p>
</li>
</ol>
<ul>
<li><p>相关命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli cluster info # 查看cluster信息</span><br><span class="line">redis-cli cluster nodes # 查看cluster节点信息</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>官方工具安装</p>
</blockquote>
<ul>
<li><p>Ruby环境准备</p>
<ul>
<li><p>下载编译安装Ruby</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tfje.png" alt="image-20230212173244781"></p>
</li>
<li><p>安装rubygem redis</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tl6n.png" alt="image-20230212173808491"></p>
</li>
<li><p>安装redis-trib.rb</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tj03.png" alt="image-20230212173825323"></p>
</li>
</ul>
</li>
<li><p>使用redis-trib.rb配置集群</p>
<ol>
<li><p>开启redis服务</p>
</li>
<li><p>一键开启</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tim2.png" alt="image-20230212174635125"></p>
<ul>
<li>–replicas：每个主节点有几个从节点</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<ol>
<li>原生命令安装<ul>
<li>理解Redis Cluster架构</li>
<li>生产环境不使用</li>
</ul>
</li>
<li>官方工具安装<ul>
<li>高效、准确</li>
<li>生产环境可以使用</li>
</ul>
</li>
<li>其他<ul>
<li>可视化部署</li>
</ul>
</li>
</ol>
<h3 id="14-4-集群伸缩"><a href="#14-4-集群伸缩" class="headerlink" title="14.4.集群伸缩"></a>14.4.集群伸缩</h3><blockquote>
<p>集群伸缩原理</p>
</blockquote>
<p>集群伸缩&#x3D;槽和数据在节点之间的移动</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tkic.png" alt="image-20230213095127707"></p>
<blockquote>
<p>扩容集群</p>
</blockquote>
<ul>
<li><p>准备新节点</p>
<ul>
<li>集群模式</li>
<li>配置与其他节点统一</li>
<li>启动后是孤儿节点</li>
</ul>
</li>
<li><p>加入集群</p>
<ul>
<li>作用：<ul>
<li>为它迁移槽和数据实现扩容</li>
<li>作为从节点负责故障转移</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tktl.png" alt="image-20230213100847052"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tk6x.png" alt="image-20230213101159575"></p>
</li>
<li><p>迁移槽和数据</p>
<ul>
<li><p>槽迁移计划</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tiuh.png" alt="image-20230213101358689"></p>
</li>
<li><p>迁移数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7twf3.png" alt="image-20230213101624014"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tpi3.png" alt="image-20230213101635209"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb reshard 127.0.0.1:6379</span><br><span class="line"><span class="comment">#指定任意一个节点即可。</span></span><br><span class="line"><span class="comment">#它首先会提示需要迁移多个槽</span></span><br><span class="line"><span class="comment">#接着它会提示需要将槽迁移到哪个节点，这里必须写节点ID。</span></span><br><span class="line"><span class="comment">#紧跟着它会提示槽从哪些节点中迁出。</span></span><br><span class="line"><span class="comment">#如果指定为all，则待迁移的槽在剩余节点中平均分配，在这里，127.0.0.1:6379和127.0.0.1:6381各迁移100个槽出来。</span></span><br><span class="line"><span class="comment">#也可从指定节点中迁出，这个时候，必须指定源节点的节点ID，最后以done结束</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加从节点</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>收缩集群</p>
</blockquote>
<ul>
<li><p>下线迁移槽</p>
</li>
<li><p>忘记节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tpy4.png"></p>
</li>
<li><p>关闭节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tuj0.png" alt="image-20230213103623046"></p>
</li>
</ul>
<h3 id="14-5-客户端路由"><a href="#14-5-客户端路由" class="headerlink" title="14.5.客户端路由"></a>14.5.客户端路由</h3><blockquote>
<p>moved重定向</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tswy.png" alt="image-20230213150528003"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tvlv.png" alt="image-20230213150634651"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tw9b.png" alt="image-20230213150738522"></p>
<blockquote>
<p>ask重定向</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u1cq.png" alt="image-20230213150928514"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u3n7.png" alt="image-20230213151025138"></p>
<blockquote>
<p>moved和ask</p>
</blockquote>
<ul>
<li>两者都是客户单重定向</li>
<li>moved：槽已经确定迁移</li>
<li>ask：槽还在迁移中</li>
</ul>
<blockquote>
<p>smart客户端</p>
</blockquote>
<ul>
<li>追求性能</li>
<li>python客户端：redis-py-cluster</li>
<li>从集群中选一个可运行节点，使用cluster slots初始化槽和节点映射</li>
<li>将cluster slots的结果映射到本地</li>
<li>准备执行命令</li>
</ul>
<h3 id="14-6-如何实现批量操作"><a href="#14-6-如何实现批量操作" class="headerlink" title="14.6.如何实现批量操作"></a>14.6.如何实现批量操作</h3><p>mget mset所有key必须在一个槽</p>
<blockquote>
<p>四种批量优化的方法</p>
</blockquote>
<ol>
<li><p>串行mget</p>
<ul>
<li>使用循环遍历每个操作</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7uiif.png" alt="image-20230213165723888"></p>
</li>
<li><p>串行IO</p>
<ul>
<li>将操作分组，分好组以后只需要执行对应集群节点数的pipeline</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ufvu.png" alt="image-20230213165808915"></p>
</li>
<li><p>并行IO</p>
<ul>
<li>将操作分组，分好组以后开启多线程进行操作</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7udy5.png" alt="image-20230213165822386"></p>
</li>
<li><p>hash_tag</p>
<ul>
<li>对key进行hash_tag包装，保证所有key在一个节点</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7uive.png" alt="image-20230213165838165"></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tyl4.png" alt="image-20230213154821670"></p>
<h3 id="14-7-故障转移"><a href="#14-7-故障转移" class="headerlink" title="14.7.故障转移"></a>14.7.故障转移</h3><blockquote>
<p>故障发现</p>
</blockquote>
<ul>
<li><p>通过ping&#x2F;pong消息实现故障发现：不需要sentinel</p>
</li>
<li><p>主观下线</p>
<ul>
<li>定义：某个节点认为另一个节点不可用</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u3c4.png" alt="image-20230213155212384"></p>
</li>
<li><p>客观下线</p>
<ul>
<li>当半数以上持有槽的主节点都编辑某节点主观下线</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tz95.png" alt="image-20230213155330930"></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ty5j.png" alt="image-20230213155456201"></p>
<blockquote>
<p>故障恢复</p>
</blockquote>
<ul>
<li><p>资格检查</p>
<ul>
<li>每个从节点检查与故障主节点的短线时间</li>
<li>超过cluster-node-timeout * cluster-slave-validity-factor取消资格</li>
<li>cluster-slave-validity-factor默认是10</li>
</ul>
</li>
<li><p>准备选举时间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7txes.png" alt="image-20230213155848015"></p>
</li>
<li><p>选举投票</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7tz1a.png" alt="image-20230213155939167"></p>
</li>
<li><p>替换主节点</p>
<ul>
<li>当前从节点取消复制变为主节点(slaveof no one)</li>
<li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己</li>
<li>向集群广播自己的pong消息，表明已经替换了故障从节点</li>
</ul>
</li>
</ul>
<h3 id="14-8-Redis-Cluster常见问题"><a href="#14-8-Redis-Cluster常见问题" class="headerlink" title="14.8.Redis Cluster常见问题"></a>14.8.Redis Cluster常见问题</h3><blockquote>
<p>集群完整性</p>
</blockquote>
<ul>
<li>cluster-require-full-coverage默认为yes<ul>
<li>集群中16384个槽全部可用：保证集群完整性</li>
<li>节点故障或者正在故障转移：(error)CLUSTERDOWN The cluster is down</li>
</ul>
</li>
<li>大多数业务无法容忍，建议设置为no</li>
</ul>
<blockquote>
<p>带宽消耗</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u6tz.png" alt="image-20230213163002619"></p>
<ul>
<li><p>消息发送频率：节点发现与其他节点最后通信时间超过cluster-node-timeout&#x2F;2时会直接发送ping消息</p>
</li>
<li><p>消息数据量：slots槽数组(2KB空间)和整个集群1&#x2F;10的状态数据(10个节点状态数据约1KB)</p>
</li>
<li><p>节点部署的机器规模：集群分布的机器越多且每台机器划分的节点数约均匀，则集群内整体的可用带宽越高</p>
</li>
<li><p>优化</p>
<ul>
<li>避免“大”集群：避免多业务使用一个集群，大业务可用多集群</li>
<li>cluster-node-timeout：带宽和故障转移速度的均衡</li>
<li>尽量均匀分配到多机器上：保证高可用和带宽</li>
</ul>
</li>
</ul>
<blockquote>
<p>Pub&#x2F;Sub广播</p>
</blockquote>
<ul>
<li>问题：publish在集群中每个节点广播：加重带宽</li>
<li>解决：单独“走”一套Redis Sentinel</li>
</ul>
<blockquote>
<p>集群倾斜</p>
</blockquote>
<ul>
<li><p>数据倾斜：内存不均</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u9qg.png" alt="image-20230213164207536"></p>
<ul>
<li><p>节点和槽分配不均</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u8su.png" alt="image-20230213164814073"></p>
</li>
<li><p>不同槽对应的键值数量差异较大</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u6er.png" alt="image-20230213165136418"></p>
</li>
<li><p>包含bigkey</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u8ax.png" alt="image-20230213165240564"></p>
</li>
<li><p>内存相关配置不一致</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7u6fg.png" alt="image-20230213165340652"></p>
</li>
</ul>
</li>
<li><p>请求倾斜：热点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ufjj.png" alt="image-20230213165610603"></p>
</li>
</ul>
<blockquote>
<p>集群读写分离</p>
</blockquote>
<ul>
<li><p>只读模式：集群模式的从节点不接受任何读请求</p>
<ul>
<li>重定向到负责槽的主节点</li>
<li>readonly命令可以读：连接级别命令</li>
</ul>
</li>
<li><p>读写分离：更加复杂</p>
<ul>
<li><p>同样的问题：复制延迟、读取过期数据、从节点故障</p>
</li>
<li><p>修改客户端：cluster slaves {nodeId}</p>
</li>
<li><p>不建议在集群模式下使用读写分离</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据迁移</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7v0ei.png" alt="image-20230213171353070"></p>
<blockquote>
<p>集群vs单机</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7v9l1.png" alt="image-20230213172002264"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ve8w.png" alt="image-20230213172219505"></p>
<h3 id="14-9-集群总结"><a href="#14-9-集群总结" class="headerlink" title="14.9.集群总结"></a>14.9.集群总结</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7ve2l.png" alt="image-20230213172431482"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vm0q.png" alt="image-20230213172657766"></p>
<h2 id="15-缓存"><a href="#15-缓存" class="headerlink" title="15.缓存"></a>15.缓存</h2><blockquote>
<p>缓存的收益与成本</p>
</blockquote>
<ol>
<li>收益<ul>
<li>加速读写<ul>
<li>通过缓存加速读写速度：CPU L1&#x2F;L2&#x2F;L3 Cache、Linux page Cache加速硬盘读写、浏览器缓存、Ehcache缓存数据库结果</li>
</ul>
</li>
<li>降低后端负载<ul>
<li>后端服务器通过前端缓存降低负载：业务端使用Redis降低后端MySQL负载等</li>
</ul>
</li>
</ul>
</li>
<li>成本<ul>
<li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li>
<li>代码维护成本：多了一层缓存逻辑</li>
<li>运维成本：例如Redis Cluster</li>
</ul>
</li>
<li>使用场景<ul>
<li>降低后端负载<ul>
<li>对高消耗的SQL：join结果集&#x2F;分组统计结果缓存</li>
</ul>
</li>
<li>加速请求响应<ul>
<li>利用redis&#x2F;Memcache优化IO响应时间</li>
</ul>
</li>
<li>大量写合并为批量写<ul>
<li>如计数器先Redis累加再批量写DB</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>缓存更新策略</p>
</blockquote>
<ul>
<li>LRU&#x2F;LFU&#x2F;FIFO算法剔除：例如maxmemory-policy</li>
<li>超时剔除：例如expire</li>
<li>主动更新：开发控制生命周期</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vhp3.png" alt="image-20230214145821951"></p>
<blockquote>
<p>缓存更新建议</p>
</blockquote>
<ul>
<li>底一致性：最大内存和淘汰策略</li>
<li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</li>
</ul>
<blockquote>
<p>缓存粒度控制</p>
</blockquote>
<ul>
<li>通用性：全量属性更好</li>
<li>占用空间：部分属性更好</li>
<li>代码维护：表面上全量属性更好</li>
</ul>
<h3 id="15-1-Redis缓存穿透"><a href="#15-1-Redis缓存穿透" class="headerlink" title="15.1.Redis缓存穿透"></a>15.1.Redis缓存穿透</h3><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最重要的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存</p>
<p>另外一些典型问题就是缓存穿透、缓存雪崩和缓存击穿</p>
<blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向存储层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了存储层数据库。这会给存储层数据库造成很大的压力，这时候就相当于出现了缓存穿透</p>
<blockquote>
<p>原因</p>
</blockquote>
<ul>
<li>业务代码自身问题</li>
<li>恶意攻击、爬虫等</li>
</ul>
<blockquote>
<p>如何发现</p>
</blockquote>
<ul>
<li>业务的相应时间</li>
<li>业务本身问题</li>
<li>相关指标：中调用书、缓存层命中数、存储层命中数</li>
</ul>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><strong>布隆过滤器</strong></li>
</ol>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z62sv4-0.png" alt="image-20230307212649862"></p>
<ol start="2">
<li><strong>缓存空对象</strong></li>
</ol>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中或区域，保护了后端数据源</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/z6gyux-0.png" alt="image-20230307212716165"></p>
<p>但是这种方法会存在两个问题：</p>
<ol>
<li>如果空值能被缓存起来，这就意味着缓存需要更多的空间存储更多的键，意味着当中可能会有很多的空值的键</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一点时间窗口的不一致，着对于需要保持一致性的业务会有影响</li>
</ol>
<p><strong>缓存击穿</strong></p>
<blockquote>
<p>概述</p>
</blockquote>
<p>这里需要注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的杠着大并发，大并发集中对着一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在屏障上凿开了一个洞</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，一次只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大</p>
<h3 id="15-2-Redis缓存雪崩"><a href="#15-2-Redis缓存雪崩" class="headerlink" title="15.2.Redis缓存雪崩"></a>15.2.Redis缓存雪崩</h3><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效，或由于cache服务承载大量请求，当cache服务异常&#x2F;脱机，流量直接压向后端组件，造成级联故障</p>
<p>产生雪崩的原因之一，比如在写文本的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而这对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/zau0br-0.png" alt="image-20230307213449287"></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点宕机，对数据库造成的压力是不可预知的，很有可能瞬间就把数据库压垮</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
<p><strong>限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能会访问的数据先预先访问一边，这样部分可能大量访问的数据就会加载到缓存中。在即将发送大并发访问前手动除法加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀</p>
<h3 id="15-3-无底洞问题"><a href="#15-3-无底洞问题" class="headerlink" title="15.3.无底洞问题"></a>15.3.无底洞问题</h3><p>“加”机器性能没有提升，反而下降了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vjjk.png" alt="image-20230214154346587"></p>
<blockquote>
<p>优化IO</p>
</blockquote>
<ul>
<li>命令本身优化：例如慢查询keys</li>
<li>减少网络通信次数</li>
<li>降低接入成本：例如客户端长连接&#x2F;连接池、NIO等</li>
</ul>
<h3 id="15-4-热点key重建优化"><a href="#15-4-热点key重建优化" class="headerlink" title="15.4.热点key重建优化"></a>15.4.热点key重建优化</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vt0m.png" alt="image-20230214155113188"></p>
<ul>
<li><p>三个目标：</p>
<ul>
<li>减少重建缓存的次数</li>
<li>数据尽可能一致</li>
<li>减少潜在危险</li>
</ul>
</li>
<li><p>两个解决</p>
<ul>
<li><p>互斥锁(mutex key)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vq6t.png" alt="image-20230214155312148"></p>
</li>
<li><p>永不过期</p>
<ul>
<li><p>缓存层面：没有设置过期时间</p>
</li>
<li><p>功能层面：为每个value添加逻辑过期时间，但发现超过逻辑过期时间后，会使用单独的线程去构建缓存</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vtj3.png" alt="image-20230214155713961"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vp4a.png" alt="image-20230214155805751"></p>
<h2 id="16-Redis云平台Cachecloud"><a href="#16-Redis云平台Cachecloud" class="headerlink" title="16.Redis云平台Cachecloud"></a>16.Redis云平台Cachecloud</h2><h3 id="16-1-Redis规模化困扰"><a href="#16-1-Redis规模化困扰" class="headerlink" title="16.1.Redis规模化困扰"></a>16.1.Redis规模化困扰</h3><blockquote>
<p>遇到的问题</p>
</blockquote>
<ul>
<li>发布构建繁琐，私搭乱盖</li>
<li>节点&amp;机器等运维成本</li>
<li>监控报警初级</li>
</ul>
<blockquote>
<p>CacheCloud</p>
</blockquote>
<ul>
<li>一键开启Redis(Standalone、Sentinel、Cluster)</li>
<li>机器、应用、实例监控和报警</li>
<li>客户端：透明使用、性能上报</li>
<li>可视化运维：配置、扩容、Failover、机器&#x2F;应用&#x2F;实例上下线</li>
<li>已经存在Redis直接接入和数据迁移</li>
<li>开源地址：<a target="_blank" rel="noopener" href="https://github.com/sohutv/cachecloud">cachecloud</a></li>
</ul>
<blockquote>
<p>使用场景</p>
</blockquote>
<ul>
<li>全量视频缓存(视频播放API)：跨机房高可用</li>
<li>消息队列同步(RedisMQ中间件)</li>
<li>分布式布隆过滤器(百万QPS)</li>
<li>计数系统：计数(播放量)</li>
<li>其他：排行榜、社交(直播)、实时计算(反作弊)等</li>
</ul>
<h2 id="17-基于Redis的分布式布隆过滤器"><a href="#17-基于Redis的分布式布隆过滤器" class="headerlink" title="17.基于Redis的分布式布隆过滤器"></a>17.基于Redis的分布式布隆过滤器</h2><blockquote>
<p>现在有50亿个电话号码，现有10万个电话号码，要快速准确判断这些电话号码是否已经存在？</p>
</blockquote>
<ul>
<li>通过数据库查询：实现快速有点难</li>
<li>数据预防在集合中：50亿 * 8字节 ≈ 40GB(内存浪费)</li>
<li>hyperloglog：准确有点难</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>垃圾邮件过滤</li>
<li>文字处理软件错误单词检测</li>
<li>网络爬虫重复url检测</li>
<li>Hbase行过滤</li>
</ul>
<h3 id="17-1-布隆过滤器原理"><a href="#17-1-布隆过滤器原理" class="headerlink" title="17.1.布隆过滤器原理"></a>17.1.布隆过滤器原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vnom.png" alt="image-20230215164518230"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w125.png" alt="image-20230215165320345"></p>
<h3 id="17-2-误差率"><a href="#17-2-误差率" class="headerlink" title="17.2.误差率"></a>17.2.误差率</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vw5t.png" alt="image-20230215165758387"></p>
<ul>
<li>与m&#x2F;n与误差率成反比，k与误差率成正比</li>
</ul>
<h3 id="17-3-布隆过滤器"><a href="#17-3-布隆过滤器" class="headerlink" title="17.3.布隆过滤器"></a>17.3.布隆过滤器</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vzxn.png" alt="image-20230215170544690"></p>
<h2 id="18-Redis开发规范"><a href="#18-Redis开发规范" class="headerlink" title="18.Redis开发规范"></a>18.Redis开发规范</h2><h3 id="18-1-键值设计"><a href="#18-1-键值设计" class="headerlink" title="18.1.键值设计"></a>18.1.键值设计</h3><blockquote>
<p>key设计</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hr0o.png" alt="image-20230216093718362"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hsjz.png" alt="image-20230216094042358"></p>
<blockquote>
<p>value设计</p>
</blockquote>
<ul>
<li><p>拒绝bigkey</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hsm8.png" alt="image-20230216094440641"></p>
<ul>
<li><p>危害</p>
<ul>
<li>网络阻塞</li>
<li>集群节点数据不均衡</li>
<li>Redis阻塞</li>
<li>频繁序列化：应用服务器CPU消耗</li>
</ul>
</li>
<li><p>bigkey发现</p>
<ul>
<li><p>应用异常</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i2lk.png" alt="image-20230216095156537"></p>
</li>
<li><p>redis-cli –bigkeys</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i0do.png" alt="image-20230216095208682"></p>
</li>
<li><p>scan+debug object</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hy9j.png" alt="image-20230216095302855"></p>
</li>
<li><p>主动报警：网络流量监控、客户端监控</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i2k6.png" alt="image-20230216095329481"></p>
</li>
<li><p>内核热点key问题优化</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i09i.png" alt="image-20230216095344680"></p>
</li>
</ul>
</li>
<li><p>bigkey删除</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hzn9.png" alt="image-20230216100117110"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i8dr.png" alt="image-20230216100257615"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i964.png" alt="image-20230216100329063"></p>
</li>
</ul>
</li>
<li><p>选择合适的数据结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i5aw.png" alt="image-20230216100535803"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i71k.png" alt="image-20230216100647284"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8iao7.png" alt="image-20230216100715810"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i5gb.png" alt="image-20230216100728958"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8i75h.png" alt="image-20230216100809373"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8iiji.png" alt="image-20230216100945573"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8igcb.png" alt="image-20230216101021982"></p>
</li>
<li><p>过期设计</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ijiw.png" alt="image-20230216101344649"></p>
</li>
</ul>
<h3 id="18-2-命令优化"><a href="#18-2-命令优化" class="headerlink" title="18.2.命令优化"></a>18.2.命令优化</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8if6h.png" alt="image-20230216101509524"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ii43.png" alt="image-20230216101610173"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ij4j.png" alt="image-20230216101724985"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8idvl.png" alt="image-20230216101842214"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8inp1.png" alt="image-20230216101943165"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8iq3l.png" alt="image-20230216102015782"></p>
<h3 id="18-3-客户端优化"><a href="#18-3-客户端优化" class="headerlink" title="18.3.客户端优化"></a>18.3.客户端优化</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8in20.png" alt="image-20230216102421026"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ios4.png" alt="image-20230216102504096"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8immj.png" alt="image-20230216103208845"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8innh.png" alt="image-20230216103838159"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8imtu.png" alt="image-20230216104150331"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8iqte.png" alt="image-20230216104220165"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ivxw.png" alt="image-20230216104301019"></p>
<h2 id="19-内存管理"><a href="#19-内存管理" class="headerlink" title="19.内存管理"></a>19.内存管理</h2><blockquote>
<p>redis内存优化</p>
</blockquote>
<ul>
<li>内存消耗</li>
<li>内存管理</li>
<li>内存优化</li>
</ul>
<h3 id="19-1-Redis内存消耗"><a href="#19-1-Redis内存消耗" class="headerlink" title="19.1.Redis内存消耗"></a>19.1.Redis内存消耗</h3><ul>
<li><p>内存使用统计</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8iz2e.png" alt="image-20230216104737483"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8isiy.png" alt="image-20230216104913879"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ix27.png" alt="image-20230216105058082"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8it26.png" alt="image-20230216105321590"></p>
</li>
<li><p>内存消耗划分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8ivnp.png" alt="image-20230216105526695"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jg4a.png" alt="image-20230216105701267"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jqri.png" alt="image-20230216105920050"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jqpd.png" alt="image-20230216110042612"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jss5.png" alt="image-20230216110147329"></p>
<ul>
<li><p>使用命令<code>client list</code>可以查看全部客户端状态</p>
</li>
<li><p><strong>复制缓冲区</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jpnl.png" alt="image-20230216110421996"></p>
</li>
<li><p><strong>AOF缓冲区</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jy8f.png" alt="image-20230216110511459"></p>
</li>
<li><p><strong>对象内存</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k0ew.png" alt="image-20230216110709244"></p>
</li>
<li><p><strong>内存碎片</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jz8p.png" alt="image-20230216110859087"></p>
</li>
</ul>
</li>
<li><p>子进程内存消耗</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jxc9.png" alt="image-20230216111012965"></p>
</li>
</ul>
<h3 id="19-2-内存管理"><a href="#19-2-内存管理" class="headerlink" title="19.2.内存管理"></a>19.2.内存管理</h3><ul>
<li><p>设置内存上限</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8jwdh.png" alt="image-20230216111141517"></p>
</li>
<li><p>动态调整内存上限</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k0aj.png"></p>
</li>
<li><p>内存回收策略</p>
<ul>
<li><p>删除过期键值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k0yy.png" alt="image-20230216111531699"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k971.png" alt="image-20230216111630575"></p>
</li>
<li><p>内存溢出策略</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k5nb.png" alt="image-20230216111812519"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k7ik.png" alt="image-20230216111827846"></p>
</li>
</ul>
</li>
</ul>
<h3 id="19-3-内存优化"><a href="#19-3-内存优化" class="headerlink" title="19.3.内存优化"></a>19.3.内存优化</h3><blockquote>
<p>一次内存暴增</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k6jy.png" alt="image-20230216112347816"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8k2q0.png" alt="image-20230216112517773"></p>
<blockquote>
<p>客户端溢出</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8kfhl.png" alt="image-20230216112620390"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8kcfo.png" alt="image-20230216112649691"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8kh1p.png" alt="image-20230216112800070"></p>
<blockquote>
<p>总结</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8kgdu.png" alt="image-20230216113015844"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8kaei.png" alt="image-20230216112953718"></p>
<h2 id="20-开发运维常见坑"><a href="#20-开发运维常见坑" class="headerlink" title="20.开发运维常见坑"></a>20.开发运维常见坑</h2><h3 id="20-1-Linux内核优化"><a href="#20-1-Linux内核优化" class="headerlink" title="20.1.Linux内核优化"></a>20.1.Linux内核优化</h3><ul>
<li><p>vm.overcommit_memory</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w1es.png" alt="image-20230215224951304"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7vym5.png" alt="image-20230215225220587"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w6wu.png" alt="image-20230215225514264"></p>
</li>
<li><p>swappiness</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w8ee.png" alt="image-20230215225701752"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w7he.png" alt="image-20230215225825384"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w6pu.png" alt="image-20230215225841425"></p>
</li>
<li><p>THP(Transparent huge page)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w3yg.png" alt="image-20230215230220547"></p>
</li>
<li><p>OOM killer</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w2km.png" alt="image-20230215230456797"></p>
</li>
<li><p>NTP(Net Time Protocol)</p>
<ul>
<li>进程的对时器</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7w4k3.png" alt="image-20230215230608498"></p>
</li>
<li><p>ulimit</p>
<ul>
<li>文件句柄数</li>
<li>最好为最大句柄数-32。因为除了客户端连接外，redis本身也需要句柄</li>
</ul>
</li>
<li><p>TCP backlog</p>
<ul>
<li>tcp握手队列</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7eqlg.png" alt="image-20230215230843170"></p>
<h3 id="20-2-安全的Redis"><a href="#20-2-安全的Redis" class="headerlink" title="20.2.安全的Redis"></a>20.2.安全的Redis</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7f6bs.png" alt="image-20230215231847087"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7f50p.png" alt="image-20230215231942792"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7f6p7.png" alt="image-20230215232223322"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7fi9q.png" alt="image-20230215232345330"></p>
<h3 id="20-3-热点key"><a href="#20-3-热点key" class="headerlink" title="20.3.热点key"></a>20.3.热点key</h3><blockquote>
<p>寻找方法</p>
</blockquote>
<ul>
<li><p>客户端</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7fj3n.png" alt="image-20230215232517913"></p>
</li>
<li><p>代理</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7fh3l.png" alt="image-20230215232549897"></p>
</li>
<li><p>服务端</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7fj54.png" alt="image-20230215232616338"></p>
</li>
<li><p>机器端</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hrxy.png" alt="image-20230215232648009"></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w8hsoa.png" alt="image-20230215232735814"></p>
<h2 id="21-Redis的python客户端"><a href="#21-Redis的python客户端" class="headerlink" title="21.Redis的python客户端"></a>21.Redis的python客户端</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/clients/">Clients | Redis</a>：Redis官方提供的各种语言的客户端</p>
<p>在这里选择下载redis-py：pip install redis[hiredis]</p>
<p>下载完成后，在python中<code>import redis</code>即可使用</p>
<h2 id="22-python使用Redis"><a href="#22-python使用Redis" class="headerlink" title="22.python使用Redis"></a>22.python使用Redis</h2><h3 id="22-1-python连接redis"><a href="#22-1-python连接redis" class="headerlink" title="22.1.python连接redis"></a>22.1.python连接redis</h3><p>redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>,db=<span class="number">0</span>)</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>)   <span class="comment">#添加</span></span><br><span class="line"><span class="built_in">print</span> (r.get(<span class="string">&#x27;name&#x27;</span>))   <span class="comment">#获取</span></span><br></pre></td></tr></table></figure>



<h3 id="22-2-连接池"><a href="#22-2-连接池" class="headerlink" title="22.2.连接池"></a>22.2.连接池</h3><p>redis-py使用<code>connectionPool</code>来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br></pre></td></tr></table></figure>



<h3 id="22-3-管道"><a href="#22-3-管道" class="headerlink" title="22.3.管道"></a>22.3.管道</h3><p> redis-py默认在执行每次请求都会创建(连接池申请连接)和断开(归还连接池)一次连接操作，如果想要在一次请求中指定多个命令，可以使用pipline实现一次请求多个命令，并且默认情况下一次pipline是原子性操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;192.228.0.110&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启管道并实例化管道对象</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行操作</span></span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure>



<h3 id="22-4-发布与订阅"><a href="#22-4-发布与订阅" class="headerlink" title="22.4.发布与订阅"></a>22.4.发布与订阅</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个发布与订阅类</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisHelper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">        self.channel = <span class="string">&#x27;moniitor&#x27;</span> <span class="comment"># 定义名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">publish</span>(<span class="params">self,msg</span>): <span class="comment"># 定义发布方法</span></span><br><span class="line">        self.__conn.publish(self.channel, msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subscribe</span>(<span class="params">self</span>): <span class="comment"># 定义订阅方法</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        pub.subscribe(self.channel)</span><br><span class="line">        pub.parse_response()</span><br><span class="line">        <span class="keyword">return</span> pub</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 发布端</span></span><br><span class="line"><span class="keyword">from</span> RedisHelper <span class="keyword">import</span>  RedisHelper</span><br><span class="line"></span><br><span class="line">obj = RedisHelper()</span><br><span class="line">obj.publish(<span class="string">&#x27;123&#x27;</span>) <span class="comment"># 发布</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅端</span></span><br><span class="line"><span class="keyword">from</span> RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"></span><br><span class="line">obj = RedisHelper()</span><br><span class="line">redis_sub = obj.subscribe()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = redis_sub.parse_response() <span class="comment"># 获取发布的信息</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure>



<h3 id="22-5-哨兵"><a href="#22-5-哨兵" class="headerlink" title="22.5.哨兵"></a>22.5.哨兵</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:/i/2023/11/19/w7snb1.png" alt="image-20230209161016993"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sentinel_list = [</span><br><span class="line">			(<span class="string">&quot;192.168.233.1&quot;</span>, <span class="string">&quot;26379&quot;</span>),</span><br><span class="line">			(<span class="string">&quot;192.168.233.2&quot;</span>, <span class="string">&quot;26379&quot;</span>),</span><br><span class="line">			(<span class="string">&quot;192.168.233.3&quot;</span>, <span class="string">&quot;26379&quot;</span>)</span><br><span class="line">		]</span><br><span class="line">mySentinel = Sentinel(sentinel_list)</span><br><span class="line">master = mySentinel.master_for(<span class="string">&quot;mymaster&quot;</span>, db=<span class="number">0</span>)</span><br><span class="line">slave = mySentinel.slave_for(<span class="string">&quot;mymaster&quot;</span>, db=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用master进行写的操作，使用slave进行读的操作</span></span><br><span class="line">master.hset(<span class="string">&quot;key_name&quot;</span>, <span class="string">&quot;filed&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">slave.hget(<span class="string">&quot;key_name&quot;</span>, <span class="string">&quot;filed&quot;</span>)</span><br><span class="line">slave.hgetall(<span class="string">&quot;key_name&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22-6-集群"><a href="#22-6-集群" class="headerlink" title="22.6.集群"></a>22.6.集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from rediscluster import StrictRedisCluster</span><br><span class="line"></span><br><span class="line">cluster_nodes = [&#123;<span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.233.1&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;9001&quot;</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.233.1&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;9002&quot;</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.233.1&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;9003&quot;</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.233.2&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;9004&quot;</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.233.2&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;9005&quot;</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.233.2&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;9006&quot;</span>&#125;]</span><br><span class="line">password = <span class="string">&quot;root&quot;</span></span><br><span class="line">conn = StrictRedisCluster(</span><br><span class="line">			startup_nodes=cluster_nodes,</span><br><span class="line">			decode_response=True,</span><br><span class="line">			password=password,</span><br><span class="line">			max_connection=300</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入值，获取值</span></span><br><span class="line">conn.set(<span class="string">&quot;key_name&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">conn.get(<span class="string">&quot;key_name&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>















</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">AYO</div><div class="post-copyright__author_desc">天行健，君子以自强不息</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/')">AYO</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=AYO&amp;url=https://ayo-al.github.io/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/&amp;pic=/img/preview.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://AYO-Al.github.io" target="_blank">AYO</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="/img/preview.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis-trib.rb/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/preview.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><b style="color:#fff">AYO的知识输出基地，</b><b style="color:#fff">以输出倒逼输入，以输出巩固知识！</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">AYO</h1><div class="author-info__desc">天行健，君子以自强不息</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/AYO-Al" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://juejin.cn/user/3708003152300183" target="_blank" title="JueJin"><i class="anzhiyufont anzhiyu-icon-book"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1.什么是Redis？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%AE%A4%E8%AF%86NOSQL"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.认识NOSQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.Redis应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">2.Redis学习准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Redis%E5%9C%A8Windows%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.Redis在Windows安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Redis%E5%9C%A8Linux%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.Redis在Linux安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.配置文件配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.</span> <span class="toc-text">2.3.Redis客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.3.1.命令行客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.3.2.图形化桌面客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3.Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-key%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.key通用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-key%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.key的层级结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-String%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-String%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1.String常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.Hash类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-Hash%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1.Hash常见命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-List%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">3.5.List类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-List%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1.List常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-set%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">3.6.set类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-Set%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1.Set常见命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">3.7.SortedSet类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-SortedSet%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1.SortedSet类型常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.8.</span> <span class="toc-text">3.8.geospatial 地理位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-GEO%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.8.1.GEO常见操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-HyperLogLog"><span class="toc-number">3.9.</span> <span class="toc-text">3.9.HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-Bitmaps"><span class="toc-number">3.10.</span> <span class="toc-text">3.10.Bitmaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-Stream"><span class="toc-number">3.11.</span> <span class="toc-text">3.11.Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-XREADGROUP-GROUP"><span class="toc-number">3.12.</span> <span class="toc-text">3.12.XREADGROUP GROUP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.</span> <span class="toc-text">4.慢查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">5.事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BA%8B%E5%8A%A1%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.事务常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">6.Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-RDB-Redis-DataBase"><span class="toc-number">6.1.</span> <span class="toc-text">6.1.RDB(Redis DataBase)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-AOF-Append-Only-File"><span class="toc-number">6.2.</span> <span class="toc-text">6.2.AOF(Append Only File)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.</span> <span class="toc-text">6.3.总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%8F%96%E8%88%8D%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-number">6.4.</span> <span class="toc-text">6.4.Redis持久化的取舍和选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text">6.5.Redis持久化运维常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">7.</span> <span class="toc-text">7.发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E8%AE%A2%E9%98%85%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">7.1.订阅常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">7.2.原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Redis%E8%BF%9E%E6%8E%A5%E5%91%BD%E4%BB%A4"><span class="toc-number">8.</span> <span class="toc-text">8.Redis连接命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Redis%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">9.Redis服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">10.</span> <span class="toc-text">10.Redis客户端连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Redis-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">11.</span> <span class="toc-text">11.Redis 性能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Redis%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF-pipeline"><span class="toc-number">12.</span> <span class="toc-text">12.Redis管道技术(pipeline)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">13.Redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">13.1.</span> <span class="toc-text">13.1.基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-Redis-Sentinel%E6%9E%B6%E6%9E%84"><span class="toc-number">13.2.</span> <span class="toc-text">13.2.Redis Sentinel架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E6%80%BB%E7%BB%93"><span class="toc-number">13.3.</span> <span class="toc-text">13.3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Redis-Cluster"><span class="toc-number">14.</span> <span class="toc-text">14.Redis Cluster</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83"><span class="toc-number">14.1.</span> <span class="toc-text">14.1.数据分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-Redis-Cluster%E6%9E%B6%E6%9E%84"><span class="toc-number">14.2.</span> <span class="toc-text">14.2.Redis Cluster架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-Redis-Cluster%E5%AE%89%E8%A3%85"><span class="toc-number">14.3.</span> <span class="toc-text">14.3.Redis Cluster安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="toc-number">14.4.</span> <span class="toc-text">14.4.集群伸缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B7%AF%E7%94%B1"><span class="toc-number">14.5.</span> <span class="toc-text">14.5.客户端路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">14.6.</span> <span class="toc-text">14.6.如何实现批量操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">14.7.</span> <span class="toc-text">14.7.故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-Redis-Cluster%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">14.8.</span> <span class="toc-text">14.8.Redis Cluster常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9-%E9%9B%86%E7%BE%A4%E6%80%BB%E7%BB%93"><span class="toc-number">14.9.</span> <span class="toc-text">14.9.集群总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%BC%93%E5%AD%98"><span class="toc-number">15.</span> <span class="toc-text">15.缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">15.1.</span> <span class="toc-text">15.1.Redis缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">15.2.</span> <span class="toc-text">15.2.Redis缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E6%97%A0%E5%BA%95%E6%B4%9E%E9%97%AE%E9%A2%98"><span class="toc-number">15.3.</span> <span class="toc-text">15.3.无底洞问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E7%83%AD%E7%82%B9key%E9%87%8D%E5%BB%BA%E4%BC%98%E5%8C%96"><span class="toc-number">15.4.</span> <span class="toc-text">15.4.热点key重建优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Redis%E4%BA%91%E5%B9%B3%E5%8F%B0Cachecloud"><span class="toc-number">16.</span> <span class="toc-text">16.Redis云平台Cachecloud</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-Redis%E8%A7%84%E6%A8%A1%E5%8C%96%E5%9B%B0%E6%89%B0"><span class="toc-number">16.1.</span> <span class="toc-text">16.1.Redis规模化困扰</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">17.</span> <span class="toc-text">17.基于Redis的分布式布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">17.1.</span> <span class="toc-text">17.1.布隆过滤器原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E8%AF%AF%E5%B7%AE%E7%8E%87"><span class="toc-number">17.2.</span> <span class="toc-text">17.2.误差率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">17.3.</span> <span class="toc-text">17.3.布隆过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="toc-number">18.</span> <span class="toc-text">18.Redis开发规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E9%94%AE%E5%80%BC%E8%AE%BE%E8%AE%A1"><span class="toc-number">18.1.</span> <span class="toc-text">18.1.键值设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-%E5%91%BD%E4%BB%A4%E4%BC%98%E5%8C%96"><span class="toc-number">18.2.</span> <span class="toc-text">18.2.命令优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">18.3.</span> <span class="toc-text">18.3.客户端优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">19.内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-Redis%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97"><span class="toc-number">19.1.</span> <span class="toc-text">19.1.Redis内存消耗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">19.2.</span> <span class="toc-text">19.2.内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">19.3.</span> <span class="toc-text">19.3.内存优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E5%9D%91"><span class="toc-number">20.</span> <span class="toc-text">20.开发运维常见坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-Linux%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96"><span class="toc-number">20.1.</span> <span class="toc-text">20.1.Linux内核优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-%E5%AE%89%E5%85%A8%E7%9A%84Redis"><span class="toc-number">20.2.</span> <span class="toc-text">20.2.安全的Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-%E7%83%AD%E7%82%B9key"><span class="toc-number">20.3.</span> <span class="toc-text">20.3.热点key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Redis%E7%9A%84python%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">21.</span> <span class="toc-text">21.Redis的python客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-python%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">22.</span> <span class="toc-text">22.python使用Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-1-python%E8%BF%9E%E6%8E%A5redis"><span class="toc-number">22.1.</span> <span class="toc-text">22.1.python连接redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">22.2.</span> <span class="toc-text">22.2.连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-%E7%AE%A1%E9%81%93"><span class="toc-number">22.3.</span> <span class="toc-text">22.3.管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-4-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-number">22.4.</span> <span class="toc-text">22.4.发布与订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-%E5%93%A8%E5%85%B5"><span class="toc-number">22.5.</span> <span class="toc-text">22.5.哨兵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-6-%E9%9B%86%E7%BE%A4"><span class="toc-number">22.6.</span> <span class="toc-text">22.6.集群</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/" title="无题">无题</a><time datetime="2024-02-17T02:05:14.289Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis-trib.rb/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis-trib.rb/" title="无题">无题</a><time datetime="2024-02-17T02:05:14.274Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/%E6%A6%82%E8%BF%B0/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2024-02-17T02:05:14.274Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" title="无题">无题</a><time datetime="2024-02-17T02:05:14.258Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%9A%8F%E7%AC%94/MySQL%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B%E6%A0%87%E5%BF%97%E4%BD%8D%E5%8F%98%E5%8C%96/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%9A%8F%E7%AC%94/MySQL%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B%E6%A0%87%E5%BF%97%E4%BD%8D%E5%8F%98%E5%8C%96/" title="无题">无题</a><time datetime="2024-02-17T02:05:14.258Z" title="发表于 2024-02-17 10:05:14">2024-02-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="/2609320892@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://regexlearn.com/zh-cn" title="Regex 101"><i class="anzhiyufont anzhiyu-icon-font"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://regexcrossword.com/" title="Regexcrossword"><i class="anzhiyufont anzhiyu-icon-bolt"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/AYO-Al" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://learngitbranching.js.org/?demo=&amp;locale=zh_CN" title="Learn Git"><i class="anzhiyufont anzhiyu-icon-pencil"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.drawio.com/" title="draw.io"><i class="anzhiyufont anzhiyu-icon-instagram"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="algolia" target="_blank" rel="noopener" href="https://www.algolia.com/">algolia</a><a class="footer-item" title="twikoo" target="_blank" rel="noopener" href="https://twikoo.js.org/">twikoo</a><a class="footer-item" title="vercel" target="_blank" rel="noopener" href="https://vercel.com/">vercel</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" target="_blank" rel="noopener" href="https://docs.anheyu.com/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" target="_blank" rel="noopener" href="https://blog.anheyu.com/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v7.0.0" title="博客框架为Hexo_v7.0.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v7.0.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2021 - 2024 By <a class="footer-bar-link" href="/" title="AYO" target="_blank">AYO</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.0.15/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/AYO-Al/AYO-Al.github.io" title="博客">博客</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/AYO-Al" title="本站项目由GitHub托管">本站项目由GitHub托管</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">1</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://git.yuki.love/" title="AYO网站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="AYO网站"/><span class="back-menu-item-text">AYO网站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/3708003152300183" title="AYO博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="AYO博客"/><span class="back-menu-item-text">AYO博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/AYO-Al" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Database/" style="font-size: 0.88rem;">Database<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/Linux" title="Linux">Linux</a><a class="tag-list" href="/tags/Database" title="Database">Database</a><a class="tag-list" href="/tags/Kubernetes" title="Kubernetes">Kubernetes</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2021 By 安知鱼 V1.6.10",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 AYO 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.56.5/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.yuki.love',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.yuki.love',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initWaline = () => {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: '',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const loadWaline = async () => {
    if (typeof Waline === 'object') initWaline()
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.css')
      await getScript('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.js')
      initWaline()
    }
  }

  if ('Twikoo' === 'Waline' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.yuki.love',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>